# Claude Code 自然言語マクロプログラミングガイド

## 🤖 Core Concept: Claude Codeをインタープリタとしたエージェントプログラミング

本ガイドは、**Claude Codeを自然言語インタープリタとして活用し、エージェントプログラミングを実現する**自然言語マクロプログラミングアプローチを提示します。

従来のプログラミングが特定の構文を持つプログラミング言語をコンピュータに解釈させるのに対し、自然言語マクロプログラミングでは：

- **自然言語とマークダウン記法**をプログラムとして記述
- **Claude Code**がそれを解釈・実行するインタープリタとして機能
- **Task tool、TODO tool、変数管理、条件分岐、並列実行**等の高度な制御構造を自然言語で実現
- **エージェントシステム**として複雑なタスクを自動化・最適化

プログラミング経験のない人でも、直感的な自然言語でエージェントの振る舞いを設計し、Claude Codeに実行させることが可能になります。

## 📊 3つの状態管理手法

Claude Code自然言語マクロプログラミングでは、異なる時間スケールでの状態管理を組み合わせることで、継続的で構造化されたタスク実行を実現します．一種の近似的RAMモデルが(おそらく)実現可能です．

### 1. 会話履歴(コンテキスト)ベースの短期記憶
- **プレースホルダー記法**: 変数参照`{{variable_name}}`で情報を構造化して記述
- **文脈ベース参照**: Claude Codeが会話履歴から関連情報を推論・参照：コンテキスト= 短期記憶
- **セッションスコープ**: 単一会話セッション内での情報継承

### 2. TODOによる構造化データ管理  
- **TODOリスト活用**: 実行状態、優先度、依存関係を含む高度なデータ構造の実現：プライオリティキュー，スタック，再帰計算の実現
- **RAMとしての役割**: 効率的データ構造実現

### 3. ファイル永続化における長期記憶
- **ファイルによる記憶永続化**
- **セッション跨ぎアクセス**: 異なる実行タイミングでの情報継承
- **経験蓄積**: Learning from Experienceパターンでの学習データ活用

これらの**状態管理手法の組み合わせ**により、単発の処理を超えた**継続的で構造化されたタスク実行**が可能になります。


## 🎯 学習内容

1. **自然言語マクロプログラミングの基本概念**
   - 情報管理と結果の受け渡し
   - 条件分岐とマルチタスク処理の実装

2. **6つのデザインパターン**
   - Sequential Pipeline（順次パイプライン）
   - Parallel Processing（並列処理）  
   - Conditional Execution（条件分岐）
   - Loop & Modular Programming（繰り返し・モジュール）
   - Problem Solving & Recursion（問題解決・再帰）
   - Learning from Experience（経験学習・知識蓄積）

3. **実践的なシステム構築能力**
   - 段階別サンプルによる実習
   - 俳句生成システム等の応用例
   - 業務自動化への応用手法

---

**Version**: 1.0  
**Authors**: Tadashi Wadayama & Claude Code (Anthropic Inc.)  
**Created**: 2025-06-18  
**License**: MIT License (2025)

---

## 🎯 研究目標

### プロジェクトの背景

Claude Codeの既存機能（Task tool、自然言語処理、マークダウン）を組み合わせることで、構造化されたタスク実行システムを構築できる可能性がある。

### 主な目的

「自然言語マクロプログラミング」により以下を実現する：

1. **非プログラマーの民主化**
   - プログラミング知識不要でエージェントシステムを構築
   - マークダウンという親しみやすい記法の活用
   - 自然言語による直感的な指示

2. **学習コストの最小化**
   - 複雑なプログラミング構文の排除
   - 段階的な学習パス（基本→応用）
   - 既存の文書作成スキルの転用

3. **設計思考の可視化**
   - 文書として読める仕様書
   - 非技術者との効果的なコラボレーション

4. **適度な制約による創造性の向上**
   - 完全自由な自然文より構造化された記法
   - 人間・LLM双方にとって理解しやすい形式
   - 再現性と保守性の確保
5. **エージェントの構造化記述**
   - 自然言語による構造化タスク記述
   - 自然言語的曖昧性を処理可能な指示
   - エラー時の段階的機能低下による継続処理
   - 経験蓄積による改善可能な処理パターン
6. **Claude Code との協働における共有ドキュメント** 
   - コンテキストにこのドキュメントをいれておくことで，「売上データについて、Parallel Processingパターンで地域別・商品別・時系列の3軸分析を並列実行し、  結果を{{analysis_result}}に統合してレポート作成までSequential Pipelineで実行してください」と言った具体性を伴う指示を出すことができる．
   - プロンプト作成をClaude Codeにさせるときに，デザインパターンを指定して指示が出せる．
   - 人間とAIの協働における共通言語としてのデザインパターン

---

## 📋 Claude Code自然言語マクロプログラミングの代表的な構文
```markdown
- 条件分岐: 自然言語による条件指示（「...の場合は」「...に応じて」など）
- `{{variable_name}}`：変数参照
- 変数への保存：「...を{{variable_name}}に保存してください」
- 永続化保存：「{{variable_name}}をfilename.jsonに保存して永続化してください」
- ファイル読み込み：「filename.jsonを読み込んで{{variable_name}}に設定してください」
- 外部モジュール実行：「filename.mdの実行をしてください」
- ツール使用：自然言語で指示（例：「Webで調べて」「ファイルを読んで」，「TODOツールを使って」）
```

### 変数管理の特徴

自然言語による統一記法を採用している：

```markdown
# 結果保存
データを分析し、結果を{{analysis_result}}に保存してください。

# 結果参照  
{{analysis_result}}を基に報告書を作成してください。
```

### 制御構造

条件分岐は自然言語で柔軟に記述できます：

```markdown
## データ処理
{{file_size}}が1MB以上の場合は詳細分析を、
それ以外の場合は基本分析を実行してください。
```

### モジュール実行

外部モジュールファイルを呼び出すことで、モジュラー設計が可能です：

```markdown
## データ処理パイプライン
data_collection.mdの実行をしてください。
data_analysis.mdの実行をしてください。
report_generation.mdの実行をしてください。

## 条件付きモジュール実行
{{data_type}}に応じて以下を実行：
- テキストデータの場合：text_analysis.mdの実行をしてください
- 数値データの場合：numerical_analysis.mdの実行をしてください
```

**モジュール実行の利点**：
- **再利用性**: 共通処理を独立したモジュールとして管理
- **保守性**: 各モジュールを独立して開発・テスト可能
- **スケーラビリティ**: 大規模システムの構築が現実的
- **協働**: チーム開発での責任分担が容易

---

## 📚 基本構文サンプル集


### 1. 順次実行：Python学習ガイド作成

```markdown
## 基本情報収集
「Python入門」についてWebで調べ、初心者向けのポイント3つを{{basics}}に保存してください。

## 学習計画作成
{{basics}}を基に、1週間の学習スケジュールを{{schedule}}に保存してください。

## 最終ガイド作成
{{basics}}と{{schedule}}を組み合わせて「Python入門ガイド」を作成してください。
```

### 2. 並列実行：朝の準備分析

```markdown
## 朝の準備ルーティン分析
**以下の3つのタスクをTask toolを利用して並列実行してください：**

### 身支度分析
朝の身支度（洗顔、歯磨き、着替えなど）の特徴と効率化のコツを分析し{{grooming}}に保存してください。

### 朝食準備分析  
朝食の準備（メニュー選択、調理、栄養バランスなど）の特徴とアイデアを分析し{{breakfast}}に保存してください。

### 出発準備分析
外出準備（持ち物確認、交通手段、時間管理など）の特徴と工夫を分析し{{departure}}に保存してください。

## 総合朝ルーティン提案
{{grooming}}、{{breakfast}}、{{departure}}を組み合わせて、効率的で充実した朝の過ごし方を提案してください。
```

### 3. 条件分岐：ファイル処理システム

```markdown
## ファイル確認
README.mdファイルのサイズ（文字数）を確認し{{file_size}}に保存してください。

## 処理方式決定
{{file_size}}に応じて以下を実行：
- 100文字未満の場合：「簡潔なファイルです。全文を表示します」と出力し、全文を{{content}}に保存
- 100文字以上の場合：「詳細なファイルです。要約を作成します」と出力し、要約を{{content}}に保存

## 結果表示
{{content}}を使って適切な形式で結果を表示してください。
```

### 4. ファイル永続化：学習進捗管理

```markdown
## 今日の学習記録
今日学習した内容を「Claude Code基本操作」として{{today_study}}に保存し、
{{today_study}}をstudy_log.jsonに保存して永続化してください。

## 進捗確認
study_log.jsonを読み込んで{{study_history}}に設定し、
学習継続日数と内容をまとめて表示してください。
```

### 5. 統合例：市場調査システム

```markdown
## 調査準備
「AI市場動向」を調査テーマとして{{theme}}に保存してください。

## 並列情報収集
**以下の3つのタスクをTask toolを利用して並列実行してください：**

{{theme}}について以下を調査してください：

### 技術動向
最新のAI技術トレンドを{{tech_trends}}に保存してください。

### 市場規模
AI市場の規模と成長予測を{{market_size}}に保存してください。

### 企業動向
主要AI企業の戦略を{{company_strategies}}に保存してください。

## 条件付きレポート作成
{{tech_trends}}、{{market_size}}、{{company_strategies}}の完全性を確認し：
- 3つすべて収集できた場合：{{tech_trends}}、{{market_size}}、{{company_strategies}}を統合した包括的な市場分析レポートを作成
- 2つ以下の場合：利用可能な情報での基本レポートを作成し、不足部分を明記

## 結果保存
最終レポートをai_market_report.jsonに保存して永続化してください。
```

---

## 🔄 基本デザインパターン

### Pattern 1: Sequential Pipeline（順次パイプライン）

**概要**: データを段階的に処理する基本パターン。`収集→処理→出力`の線形フローで確実な結果を得る。

**処理フロー**: `入力 → 処理1 → 処理2 → 処理3 → 出力`

**適用判断**:
- ✅ 処理に明確な順序がある
- ✅ 前段階の結果が次段階の入力になる
- ✅ 各段階を独立してテスト・改善したい
- ❌ 各処理が完全に独立している（→Parallel Processingを検討）

**実用例：ブログ記事作成システム**
```markdown
## トピック調査
「リモートワークのメリット」についてWebで調べ、主要なポイント5つを{{research}}に保存してください。

## 構成作成
{{research}}を基に、読みやすいブログ記事の構成（見出し3-5個）を{{structure}}に保存してください。

## 記事執筆
{{structure}}に従って、1500文字程度のブログ記事を執筆し{{article}}に保存してください。

## 最終確認
{{article}}の文章を校正し、読みやすさと正確性を確認して最終版を作成してください。
```

**習得のポイント**: 各段階で前の結果を必ず活用する変数設計が重要である

### 🛡️ ロバストなSequential Pipeline（大規模タスク対応）

**課題の認識**: 各段階のタスクが大きく複雑な場合、以下の問題が発生する可能性がある：
- 途中での処理失敗時の復旧困難
- 長時間実行における進捗管理の欠如  
- セッション中断時の再開困難
- 部分的完了状況の不透明性

**解決アプローチ**: TODOリストツールとの統合により、堅牢性と追跡可能性を向上させる

**改良ポイント**:
- **段階的分解**: 各メイン段階をサブタスクに細分化してTODO管理
- **進捗可視化**: 完了状況のリアルタイム確認
- **状態永続化**: セッション跨ぎでの継続実行対応
- **失敗回復**: 部分的失敗からの効率的復旧

**実用例：大規模調査レポート作成システム**
```markdown
## Phase 1: 調査計画の策定
以下のサブタスクをTODOリストに追加してください：
1. 「調査テーマの詳細化と範囲設定」- 優先度: 高
2. 「主要情報源の特定とアクセス可能性確認」- 優先度: 高  
3. 「調査手法の決定と実行計画策定」- 優先度: 中
4. 「スケジュールとマイルストーンの設定」- 優先度: 中

各タスクを順次実行し、完了時にステータスを「completed」に更新してください。

## Phase 2: 文献調査の実行
前フェーズ完了後、以下をTODOリストに追加：
1. 「学術論文の検索と収集」- 優先度: 高
2. 「業界レポートの分析」- 優先度: 高
3. 「統計データの取得と整理」- 優先度: 中
...

## 進捗確認
各フェーズ完了時に全体の進捗状況を確認し、次フェーズへの移行判定を実行してください。
```

**適用判断**:
- ✅ 総実行時間が30分以上の大規模タスク
- ✅ 複数セッションに跨る可能性がある処理
- ✅ 部分的失敗からの復旧が重要な業務
- ✅ 進捗の可視化・追跡が必要なプロジェクト
- ❌ 5分以内で完了する軽量タスク（→基本版を使用）

**習得のポイント**: TODOリストとSequential Pipelineの統合により、大規模タスクの体系的管理手法を習得

---

### Pattern 2: Parallel Processing（並列処理）

**概要**: 独立したタスクを同時実行して効率化と多角的視点を実現する処理パターン。

**処理フロー**: `入力 → [タスクA, タスクB, タスクC] → 統合 → 出力`

**適用判断**:
- ✅ 各処理が互いに独立している
- ✅ 同一データに対する異なる視点の分析が必要
- ✅ 処理時間の短縮が重要
- ❌ 処理に厳密な順序がある（→Sequential Pipelineを検討）

**実用例：週末の過ごし方分析システム**
```markdown
## 分析対象設定
「充実した週末」を分析対象として{{weekend}}に保存してください。

## 並列活動分析
**以下の3つのタスクをTask toolを利用して並列実行してください：**

{{weekend}}について以下の活動を分析してください：

### インドア活動分析
家で楽しめる活動（読書、映画、料理など）の特徴を分析し{{indoor}}に保存してください。

### アウトドア活動分析
外で楽しめる活動（散歩、スポーツ、旅行など）の特徴を分析し{{outdoor}}に保存してください。

### 社交活動分析
人との交流を楽しむ活動（友人との食事、イベント参加など）の特徴を分析し{{social}}に保存してください。

## 週末プラン提案レポート
{{indoor}}、{{outdoor}}、{{social}}を組み合わせて、バランスの取れた週末の過ごし方を提案してください。
```

**習得のポイント**: 各並列タスクが独立していることを確認し、必ず統合段階を設けることが重要である

---

## 🎌 実践例解説：俳句生成マルチエージェントシステム

**ファイル**: [`haiku_direct.md`](./haiku_direct.md)

### システム概要

俳句生成マルチエージェントシステムは、**Sequential Pipeline**と**Parallel Processing**を組み合わせた実用的な例である。創作プロセスをマクロ化することで、一貫した品質の俳句を効率的に生成する。

### 🏗️ システム構造分析

#### Phase 1: Sequential Pipeline（順次実行）
```
テーマ生成 → 俳句並列作成 → 俳句評価・選択 → 最終レポート
```

**設計判断**: 各段階が前段階の結果に依存するため、Sequential Pipelineを採用

#### Phase 2: Parallel Processing（並列実行）
```
俳句並列作成セクション内：
├── Task 1: 第1テーマ俳句 (並列)
├── Task 2: 第2テーマ俳句 (並列)  
├── Task 3: 第3テーマ俳句 (並列)
└── Task 4: 第4テーマ俳句 (並列)
```

**設計判断**: 各俳句の作成は独立しているため、Parallel Processingで効率化

### 🔄 データフロー設計

**変数管理の巧妙な活用**：

1. **テーマ共有**: `{{themes}}` → 全ての並列タスクで共通利用
2. **個別結果**: `{{haiku_1}}`, `{{haiku_2}}`, `{{haiku_3}}`, `{{haiku_4}}` → 独立保存
3. **評価統合**: `{{best_selection}}` → 並列結果の統合評価
4. **最終出力**: 全変数を参照した包括的レポート

### 💡 学習ポイント

#### 1. パターンの適切な組み合わせ
- **外枠**: Sequential Pipeline（プロセス全体）
- **内部**: Parallel Processing（俳句生成部分）
- **全体**: 単一の統合されたシステム

#### 2. 変数設計の工夫
```markdown
# 共通入力変数
{{themes}} → 全並列タスクで使用

# 個別出力変数  
{{haiku_1}}, {{haiku_2}}, {{haiku_3}}, {{haiku_4}} → 各タスクの独立結果

# 統合変数
{{best_selection}} → 並列結果の評価・選択
```

#### 3. 実用的な品質管理
- **多様性確保**: 4つの異なるテーマで多角的アプローチ
- **客観評価**: 明確な評価基準による選択プロセス
- **包括記録**: 全工程の結果を最終レポートで保存

### 🎯 実装の特徴

#### 自然言語による直感的指示
```markdown
# 技術的でない、自然な表現
「5-7-5の音律構造に従い、テーマの奇妙さと独特さを表現してください」
「最も奇妙で印象的な俳句を選択してください」
```

#### 完全な自動化
- 人間の介入なしで完結
- 全プロセスが自動実行
- 一貫した品質の保証

### 📈 応用可能性

このシステム構造は以下の分野への応用が考えられる：

- **創作活動**: 小説、詩、キャッチコピー生成
- **コンテンツ制作**: 記事、プレゼン資料、企画書
- **意思決定支援**: 複数案の生成・評価・選択
- **品質保証**: 多角的検証による品質向上

### 🎓 学習効果

`haiku_direct.md`を理解することで以下が期待される：

1. **基本パターンの実践的組み合わせ**の習得
2. **変数管理の効果的な設計手法**の理解  
3. **実用的なシステム構築能力**の獲得
4. **自然言語マクロプログラミングの本質**の体得

このファイルは、基本パターンから実用システムへの**有用な架け橋**となる学習教材である。

---

### Pattern 3: Conditional Execution（条件分岐）

**概要**: 状況に応じて異なる処理パスを動的に選択。データ特性やユーザー状況による最適な処理を実現し、柔軟で実用的なシステムを構築。

**処理フロー**: `入力 → 条件判定 → [処理A | 処理B | 処理C] → 出力`

**適用判断**:
- ✅ データや状況によって処理を変える必要がある
- ✅ エラーハンドリングや例外処理が重要
- ✅ ユーザー権限や設定による機能制御が必要
- ❌ 常に同じ処理で十分（→[Sequential Pipeline](./examples/sequential_pipeline/)を検討）
- ❌ 複雑な問題分割が必要（→[Problem Solving & Recursion](./examples/problem_recursion/)を検討）

**実用例：曖昧要求解釈システム（自然言語曖昧性フォールバック）**
```markdown
## 曖昧要求の入力
以下のような意図的に曖昧な表現で要求を入力してください：
- 「AIについて調べて」
- 「教育への影響を知りたい」
- 「それについてもっと」

あなたの曖昧な要求を{{user_request}}に保存してください。

## 曖昧性レベル判定・解釈
{{user_request}}の曖昧性を判定し、解釈を{{interpretation}}に保存してください。

## 曖昧性に応じたフォールバック実行
{{user_request}}の曖昧性レベルに応じて：

高度な曖昧性の場合：
→ 「最も可能性の高い解釈として調査します」と推測実行
→ 「高度な推測による解釈です」を{{uncertainty_note}}に記録

中程度の曖昧性の場合：
→ 「文脈から推測して調査します」と部分推測実行
→ 「部分的推測を含みます」を{{interpretation_note}}に記録

## 曖昧性処理結果の体験
推測の妥当性、フォールバック価値、透明性を確認し、
自然言語曖昧性フォールバックを実体験してください。
```

**習得のポイント**: 全ての条件パターンを網羅し、明確な判定基準を設定することが重要である

### 🤖 エージェント型の例：週間タスク管理エージェント

エージェントプログラミングの核心概念「**環境センシング→判断→行動**」を実装する例：

```markdown
## 環境センシング：現在の曜日取得
dateコマンドを実行して現在の曜日を確認し、{{current_day}}に保存してください。

## 曜日別タスク実行
{{current_day}}に応じて以下を実行し、結果を{{daily_result}}に保存してください：

月曜日の場合：
→ 週始めプランニング（1週間の目標設定）を実行

火曜日〜木曜日の場合：
→ 集中作業モード（重要タスクの進捗確認）を実行

金曜日の場合：
→ 週末準備モード（週の振り返りと次週準備）を実行

土曜日・日曜日の場合：
→ リフレッシュモード（休息とリチャージ活動）を実行

## エージェント動作報告
{{current_day}}と{{daily_result}}を組み合わせて、今日のエージェント動作報告書を作成してください。
```

**エージェントプログラミングの要素**:
- **環境認識**: dateコマンドによる実世界情報の取得
- **状況判断**: 曜日情報に基づく論理的な条件分岐
- **適応行動**: 各状況に最適化された異なる行動パターンの実行
- **状態管理**: センシング結果と行動結果の統合的な管理

---

## 🛡️ Graceful Degradation（優雅な機能低下）

**概要**: 理想的な条件を満たせない場合でも完全停止せず、段階的に品質を調整して可能な限りの価値を提供する設計原則。自然言語マクロの堅牢性を支える核心概念。

### 📋 核心原則

**4段階フォールバック戦略**: `理想 → 代替 → 最小 → エラー対応`

1. **部分価値の提供**: 完璧でなくても有用な結果を提供
2. **透明性の確保**: 制限事項を明確にユーザーに伝達
3. **段階的適応**: 状況に応じた品質レベルの調整
4. **回復可能性**: 条件改善時の自動復旧

### 🔧 実用例：適応型レポート生成システム

```markdown
## リソース状況確認
Web検索、データベース、専門資料の利用可能性を確認し{{resources}}に保存してください。

## 適応的レポート生成
{{resources}}に基づいて以下を実行：

完全リソース利用可能の場合：
→ 最新データ、専門分析、詳細な予測を含む包括的レポートを作成し{{full_report}}に保存してください

Web検索のみ利用可能の場合：
→ 公開情報に基づく基本レポートを作成し{{basic_report}}に保存してください
→ 「公開情報のみに基づく分析です。専門データは含まれていません」を{{limitation}}に記録してください

リソース大幅制限の場合：
→ 一般的な概要と分析フレームワークを提供し{{framework}}に保存してください
→ 「制約により概要レベルです。詳細化には追加リソースが必要です」を{{status}}に記録してください

## 品質レベル明示
作成されたレポート（{{full_report}}、{{basic_report}}、または{{framework}}）のレベルを明示し、
制限事項（{{limitation}}または{{status}}）と改善方法を説明してください。
```

**設計のポイント**：
- ❌ 「データ不足で処理できません」
- ✅ 「限定的データですが、以下の傾向が確認できます」+ 改善提案

この原則により、自然言語マクロシステムは**多くの状況で価値を提供**する実用的なツールとなる。

### 🔤 曖昧性許容処理（Ambiguity Tolerance）

**概要**: 自然言語処理ならではの特性を活用し、不明確な要求でも推測ベースで価値を提供する設計原則。従来のプログラミングでは「エラー」として処理される曖昧性を、システムの柔軟性として活用するアプローチ。

**4段階曖昧性対応戦略**: `明確 → 部分推測 → 高度推測 → 解釈不能`

1. **推測ベース継続**: エラー終了ではなく推測による処理継続
2. **確信度明示**: 推測レベルと不確実性をユーザーに透明化
3. **段階的詳細化**: より明確な要求への改善ガイダンス提供
4. **価値提供継続**: 最悪条件でも基本的フレームワークを提供

### 実用例：曖昧要求の段階的処理

```markdown
## 曖昧要求の解釈
{{user_request}}の曖昧性レベルを判定し、以下を実行：

明確な要求の場合：
→ 確定的に処理を実行し{{definitive_result}}に保存

部分的曖昧性の場合：
→ 「文脈から推測して処理します」として実行し{{inferred_result}}に保存
→ 「部分的推測を含みます」を{{uncertainty_note}}に記録

高度な曖昧性の場合：
→ 「最も可能性の高い解釈として処理します」として実行し{{speculative_result}}に保存
→ 「高度な推測による解釈です」を{{speculation_note}}に記録

解釈不能の場合：
→ 一般的なフレームワークを提供し{{fallback_framework}}に保存
→ 「具体的な要求の再入力を推奨します」を{{clarification_request}}に記録
```

### 🆚 従来プログラミングとの差別化

#### 従来のシステム設計
```
曖昧入力 → エラー → 処理停止 → ユーザー離脱
```

#### 曖昧性許容システム
```
曖昧入力 → 推測処理 → 有用結果 + 不確実性明示 → 段階的改善
```

**自然言語マクロプログラミングの独自価値**：
- **バイナリ判定からスペクトラムへ**: 成功/失敗ではなく確信度の段階的評価
- **完璧性から実用性へ**: 完全理解より部分的でも有用な価値提供
- **エラーから機会へ**: 曖昧性を柔軟性として活用する設計思想

この曖昧性許容処理により、人間-AI間の自然な対話における曖昧性への対応が改善され、より実用的なシステムの構築が可能となる。不確実な情報に基づく状況下においてエージェントが「完全停止」ではなく「推測継続」による処理を行うためのアプローチとなる。

---

## 📁 実践サンプル集

基本3パターンの詳細な実践例を以下で学習できる：

### 🔄 Sequential Pipeline（順次パイプライン）
- **初級**: [ブログ記事作成システム](./examples/sequential/blog_creation.md) - テーマ設定から校正まで
- **中級**: [学術調査パイプライン](./examples/sequential/research_pipeline.md) - 仮説構築から論文執筆まで
- **上級**: [大規模調査レポート作成システム](./examples/sequential/robust_research_system.md) - TODO統合ロバスト版

### ⚡ Parallel Processing（並列処理）
- **初級**: [市場分析システム](./examples/parallel/market_analysis.md) - 技術・市場・競合の同時調査
- **中級**: [競合調査システム](./examples/parallel/competitive_research.md) - 5社の並列企業分析

### 🎌 Conditional Execution（条件分岐）
- **初級**: [適応型学習システム](./examples/conditional/adaptive_tutor.md) - レベル別カリキュラム提供
- **中級**: [曖昧要求解釈システム](./examples/conditional/content_processor.md) - 自然言語曖昧性フォールバック

---

### Pattern 4: Loop & Modular Programming（状態管理・反復処理・モジュール設計）

**概要**: 状態を保持しながら反復的に処理を実行し、複雑なロジックを外部モジュールに分離してシステムの保守性と再利用性を向上させる高度なパターン。単純な反復処理から、条件制御と安全機構を備えた実用的なループシステムまでを段階的に構築。

**処理フロー**: `初期化 → [状態更新 → 外部モジュール実行 → 条件判定] → 終了処理`

**適用判断**:
- ✅ 状態を更新しながら反復処理が必要
- ✅ 継続的な改善や学習プロセスを実装したい
- ✅ 複雑な処理ロジックをループ内で実行する場合
- ✅ ループ処理の可読性と保守性が重要
- ✅ 条件制御と安全機構を備えたループが必要
- ❌ 状態変更のない単純な繰り返し（→基本的な反復で十分）

**モジュラー設計の価値**:
- **可読性**: ループ制御と処理ロジックの分離
- **再利用性**: 処理モジュールの独立した利用
- **保守性**: 各部分の独立した開発・テスト
- **スケーラビリティ**: 大規模システムの構築

### 🔢 基本例：シンプルなカウントアップシステム

まず、Loop & Modular Programmingの最も基本的な概念を理解するために、シンプルな固定回数ループから始めます：

```markdown
## 初期設定
カウンターを0として{{counter}}に設定してください。
合計値を0として{{total}}に設定してください。

## 5回繰り返しループ
以下を5回繰り返してください：

{{counter}}に1を加算してください。
{{total}}に{{counter}}を加算してください。
「回数: {{counter}}, 現在の合計: {{total}}」と表示してください。

## 最終結果
「完了！最終回数: {{counter}}, 総合計: {{total}}」と表示してください。
```

**学習ポイント**:
- **状態変数**: `{{counter}}`と`{{total}}`が各ループで更新される
- **固定回数**: 5回という明確な終了条件
- **状態の蓄積**: 繰り返しにより値が段階的に変化

### 🏗️ 応用例：モジュラー品質改善システム

*メインループファイル (main_improvement.md)*:
```markdown
## 初期設定
品質スコアを40として{{score}}に設定してください。
改善回数を0として{{iteration}}に設定してください。
改善履歴を空の状態として{{improvement_log}}に設定してください。

## 品質改善ループ
{{score}}が85以上または{{iteration}}が8回に達するまで以下を繰り返してください：

「=== 改善サイクル {{iteration}} 開始 ===」と表示してください。

improvement_process.mdの実行をしてください。

{{iteration}}に1を加算してください。

「=== 改善サイクル {{iteration}} 完了 ===」と表示してください。

## 最終結果報告
「品質改善プロセス完了」と表示してください。

以下の情報を報告してください：
- 最終品質スコア: {{score}}
- 実行した改善回数: {{iteration}}
- 改善履歴: {{improvement_log}}

改善プロセス全体の評価を実行してください。
```

*処理モジュールファイル (improvement_process.md)*:
```markdown
## 現在状況の分析
現在の品質スコア{{score}}を確認し、「現在のスコア: {{score}}」と表示してください。

## 適応的改善処理
{{score}}の値に応じて以下の改善処理を実行してください：

{{score}}が60未満の場合：
→ 「基礎改善処理を実行します」と表示してください
→ {{score}}に12を加算してください
→ 「基礎改善: +12点」を{{improvement_log}}に追記してください

{{score}}が60以上75未満の場合：
→ 「中級改善処理を実行します」と表示してください  
→ {{score}}に8を加算してください
→ 「中級改善: +8点」を{{improvement_log}}に追記してください

{{score}}が75以上85未満の場合：
→ 「高級改善処理を実行します」と表示してください
→ {{score}}に5を加算してください
→ 「高級改善: +5点」を{{improvement_log}}に追記してください

{{score}}が85以上の場合：
→ 「微調整処理を実行します」と表示してください
→ {{score}}に2を加算してください
→ 「微調整: +2点」を{{improvement_log}}に追記してください

## 改善結果の記録
改善後の新しいスコア{{score}}を表示してください。

実行した改善の種類と効果を確認し、「改善処理完了」と表示してください。
```

### 🔄 終了条件の3つのパターン

#### 1. 純粋条件終了
```markdown
{{score}}が目標値に達するまで処理を継続：
→ 回数制限なし、条件のみで終了判定
→ 確実な目標達成、予測可能な収束
```

#### 2. 複数条件終了
```markdown
以下のいずれかが満たされるまで継続：
→ 品質目標達成 OR エラーゼロ達成 OR 改善停滞検出
→ 複雑な終了判定、柔軟な制御
```

#### 3. 安全機構付き終了
```markdown
主条件: {{score}} >= 目標値
安全制限: 最大{{max_iterations}}回まで
→ 無限ループ防止、実用的な制限設定
```

**習得のポイント**: 
1. **ループ制御と処理ロジックの分離**により複雑度を管理
2. **状態変数の一貫した管理**で予測可能な動作を実現  
3. **適切な終了条件設計**で実用性と安全性を両立
4. **外部モジュール実行**で再利用可能なコンポーネント設計

### 📁 実践サンプル

Loop & Modular Programming の詳細な実践例：

- **初級**: [学習進捗管理システム](./examples/loop_modular/learning_progress.md) - スコア向上の反復学習
- **中級**: [プレゼンテーション品質最適化システム](./examples/loop_modular/presentation_optimizer.md) - 複数軸での反復改善



---

### Pattern 5: Problem Solving & Recursion（動的問題解決・再帰的分割）

**概要**: 複雑な問題をTODOツールを活用して再帰的に分割し、段階的に解決する高度なパターン。大きな問題を理解可能な単位まで分解し、確実な進歩を積み重ねて最終的な統合解決を実現。

**処理フロー**: `問題分析 → 分解判定 → [再帰分割 | 具体実行] → 統合解決`

**適用判断**:
- ✅ 複雑で多段階の問題解決が必要
- ✅ 問題を段階的に分割できる構造
- ✅ 確実な進捗管理と状態保持が重要
- ✅ 中断・再開可能な長期タスク
- ❌ 単純で分割不要な処理（→[Sequential Pipeline](./examples/sequential_pipeline/)を検討）


**再帰的思考の価値**:
- **分解**: 大きな問題を理解可能な単位に分割
- **判定**: 各タスクの分解可能性を適切に評価
- **実行**: 分解不可能なタスクの具体的完了
- **統合**: 分散した成果の体系的な結合

### 🎯 段階的学習の3ステップ

#### ステップ1: TODOツール基本操作
```markdown
## TODOリスト基本操作体験

簡単なタスク「買い物リスト作成」でTODOツールの基本操作を習得：

現在のTODOリストを確認してください。

以下のタスクをTODOリストに追加してください：
1. 「食材確認」- 優先度: 高
2. 「買い物リスト作成」- 優先度: 高  
3. 「買い物実行」- 優先度: 中

各タスクを順次実行し、完了時にステータスを「completed」に更新してください。

最終的にすべてのタスクが完了したことを確認してください。
```

#### ステップ2: 基本的な問題分割
```markdown
## 単純な問題分割システム

メインタスク「週末の掃除計画」を分割してTODOリストで管理：

メインタスクを以下のサブタスクに分割してTODOリストに追加：
1. 「リビング掃除」- 優先度: 高
2. 「キッチン掃除」- 優先度: 高
3. 「バスルーム掃除」- 優先度: 中
4. 「ゴミ出し」- 優先度: 低

各サブタスクについて：
- 具体的な作業内容を決定
- 作業完了後、ステータスをcompletedに更新
- 全完了後、掃除計画全体の成果をまとめて報告
```

#### ステップ3: 再帰的問題解決
```markdown
## 高度な再帰分割システム

メインタスク「料理レシピ作成」による再帰実装：

## フェーズ1: 初期問題分割
メインタスクを主要サブタスクに分解してTODOリストに追加

## フェーズ2: 再帰的分解判定
各pendingタスクについて：
- 分解可能性を判断
- 分解可能→詳細サブタスクを作成してTODO追加
- 分解不要→具体的作業を実行してcompleted

## フェーズ3: 継続的処理
pendingタスクが残る限り、フェーズ2を繰り返し実行

## フェーズ4: 最終統合
全タスク完了後、結果を統合して完全なレシピとして提示
```

### 🔄 再帰的思考の3つの利点

#### 1. 複雑度の管理
```markdown
大きな問題 → 理解可能な単位 → 段階的解決：
→ 人間の認知限界を考慮した分割
→ 各ステップでの確実な理解と実行
```

#### 2. 確実な進歩保証
```markdown  
分解不可能 → 具体実行 → completed → 積み重ね：
→ 各タスク完了が全体の前進を保証
→ 中途半端な状態を残さない設計
```

#### 3. 中断・再開可能性
```markdown
TODOリスト → 状態保持 → セッション跨ぎ → 継続処理：
→ 長期プロジェクトの柔軟な管理
→ 複数人での作業分担も可能
```

**習得のポイント**: 
1. **再帰的分解思考**でプログラミング的問題解決を習得
2. **TODOツール連携**による確実な状態管理を実現
3. **分解判定ロジック**で適切な粒度制御を学習
4. **統合プロセス**で分散した成果の体系化を実践

### 📁 実践サンプル

Problem Solving & Recursion の詳細な実践例：

- **初級**: [タスク分解システム](./examples/problem_recursion/task_decomposition.md) - カレーレシピ作成による再帰分割の実践（実行時間: 3-5分）
- **中級**: [プロジェクト管理システム](./examples/problem_recursion/project_management.md) - 複雑な階層管理とイベント企画の完全分解（実行時間: 8-12分）

---

### Pattern 6: Learning from Experience（経験学習・知識蓄積・記憶管理）

**概要**: エージェントが実行した処理の結果を永続化ファイルに保存し、蓄積された経験から学習して意思決定の質を向上させる高度なパターン。単純な経験記録から、類似性判定による知見検索、失敗パターン認識まで段階的に構築。

**処理フロー**: `経験記録 → 知見蓄積 → 経験検索 → 知見活用`

**適用判断**:
- ✅ 過去の経験を活用して判断精度を向上させたい
- ✅ 継続的な学習・改善プロセスを実装したい  
- ✅ 類似状況での知見を効率的に利用したい
- ✅ 失敗パターンの予測・回避システムを構築したい
- ❌ 単発処理で記憶が不要（→基本パターンを検討）

**経験学習の価値**:
- **記憶**: 過去の成功・失敗事例の永続化
- **学習**: 経験からパターンを抽出し知見化
- **検索**: 類似状況での関連経験の効率的発見
- **活用**: 蓄積された知識に基づく改善された意思決定

### 🍳 基本例：料理経験の蓄積学習システム

まず、Learning from Experienceの最も基本的な概念として、経験の記録→蓄積→活用サイクルを実践します：

```markdown
## 初期料理実験
今日の夕食として「チャーハン」を作ってみます。

使用材料: 米2合、卵2個、ネギ、醤油、塩
調理時間: 20分
評価: 味が薄い、べたつき気味（5/10点）

## 経験の記録
以下の料理経験をlearning_memory.jsonファイルに保存して永続化してください：

{
  "cooking_experiences": [
    {
      "date": "今日",
      "dish": "チャーハン",
      "ingredients": ["米2合", "卵2個", "ネギ", "醤油", "塩"],
      "cooking_time": 20,
      "score": 5,
      "problems": ["味が薄い", "べたつき気味"],
      "lessons": "調味料の量要調整、火力強化必要"
    }
  ]
}

## 改善実践
learning_memory.jsonを読み込んで{{past_experience}}に設定してください。

{{past_experience}}の教訓を活用して改善版チャーハンを作ります：

改善材料: 米2合、卵2個、ネギ、醤油（多め）、塩、鶏ガラスープ、ごま油
調理時間: 18分
評価: 味が濃厚、パラパラ食感（8/10点）

この改善結果も{{past_experience}}に追加してlearning_memory.jsonに保存してください。

## 学習完了とクリーンアップ
「料理学習サイクル完了！」と表示してください。

次回実行時のために、learning_memory.jsonファイルを削除してください。
```

**学習ポイント**:
- **経験記録**: 具体的な結果をJSON形式で永続化
- **教訓抽出**: 問題点から具体的な改善点を導出
- **知見活用**: 過去経験を参照した改善実践

### 🔄 継続学習：Loop Pattern + Learning from Experience

数当てゲーム学習システムでは、過去の推定履歴を活用して段階的に効率的な探索戦略を習得します：

```markdown
## ゲーム初期設定
1から100までの数からランダムに秘密の数を選択し{{secret_number}}に設定してください。
（動作確認のため、秘密の数を表示してください）

game_history.jsonを読み込んで{{game_history}}に設定してください。
推定回数を0として{{attempt_count}}に設定してください。

## 学習推定ループ
{{attempt_count}}が10回に達するか正解するまで以下を繰り返してください：

{{attempt_count}}に1を加算してください。

「=== 推定回数 {{attempt_count}} ===」と表示してください。

## 過去履歴に基づく推定値決定
{{game_history}}を参照して次の推定値を決定してください。

初回の場合：
→ 1から100の間で推定値を選択してください

2回目以降の場合：
→ {{game_history}}の内容を確認し、あなたなりの方法で次の推定値を決定してください

推定値を{{current_guess}}に設定し、「推定値: {{current_guess}}」と表示してください。

## フィードバック判定
{{current_guess}}と{{secret_number}}の差を計算し、以下の段階的フィードバックを提供してください：

差が20以上の場合：
→ {{current_guess}} < {{secret_number}}: 「{{current_guess}}はだいぶ小さいです」
→ {{current_guess}} > {{secret_number}}: 「{{current_guess}}はだいぶ大きいです」

差が5-19の場合：
→ {{current_guess}} < {{secret_number}}: 「{{current_guess}}は少し小さいです」
→ {{current_guess}} > {{secret_number}}: 「{{current_guess}}は少し大きいです」

差が1-4の場合：
→ 「{{current_guess}}はとても近いです！」

差が0の場合：
→ 「正解！{{current_guess}}が秘密の数です！」と表示してループ終了

## 履歴更新
推定結果を{{game_history}}に追加し、game_history.jsonに保存してください：
- 推定回数
- 推定値
- フィードバック結果
- あなたが気づいたこと（任意）

## 最終学習成果
ゲーム完了後、{{game_history}}から学習プロセスを振り返ってください：
「数当て学習完了！{{attempt_count}}回で正解到達」
「あなたが発見した学習効果や戦略について自由に分析してください」

## 学習完了とクリーンアップ
次回実行時のために、game_history.jsonファイルを削除してください。
```


**習得のポイント**: 
1. **経験永続化**でセッション跨ぎの長期記憶を実現
2. **継続学習サイクル**で反復的な改善プロセスを構築
3. **知見抽出**で個別経験から一般的な法則性を発見
4. **状態管理**で学習の進歩を追跡・可視化

### 📁 実践サンプル

Learning from Experience の詳細な実践例：

- **初級**: [文章スタイル分析・改善システム](./examples/learning_experience/writing_style_learning.md) - JSON永続化による文章経験の記録・蓄積・活用（実行時間: 5-8分）
- **中級**: [プロンプト継続改良システム](./examples/learning_experience/prompt_improvement_learning.md) - Loop Pattern統合による段階的プロンプト最適化学習（実行時間: 8-12分）
- **上級**: [完全ブラインド最適化学習システム](./examples/learning_experience/blind_optimization_learning.md) - 真のブラインド探索環境での最適解発見学習（実行時間: 3-6分）

---


### 🚀 実用システム構築への道筋

基本パターンの習得後は、以下の段階で実用的なエージェントシステムを構築できます：

**段階1: パターン組み合わせ**
- 複数パターンを組み合わせた複合システム設計
- [`haiku_direct.md`](./haiku_direct.md)のような統合システム理解

**段階2: 業務特化システム**
- 自身の業務や興味分野でのカスタムシステム設計
- 企業・団体でのワークフロー自動化への応用

**段階3: 高度なエージェント設計**
- 環境センシング→判断→行動の高度な実装
- 学習・適応機能を持つ進化的システム構築

### 💡 活用のコツ

- **小さく始める**: 簡単な例から徐々に複雑化
- **反復改善**: 基本動作確認後に段階的に機能追加
- **再利用重視**: 成功したパターンの他分野での転用
- **文書化習慣**: システムの意図と制約の明確な記録

Claude Codeを自然言語インタープリタとして活用することで、プログラミング経験に関係なく、実用的で強力なエージェントシステムの構築が可能になります。