# Claude Code 自然言語マクロプログラミングガイド

**Claude Code**は、Anthropic社が開発したAIアシスタントClaudeを拡張したコーディング専用環境である（[公式ドキュメント](https://docs.anthropic.com/en/docs/claude-code)）。ファイル操作、Bash実行、Web検索などの強力なツール群を統合し、プログラミングから文書作成まで幅広いタスクを支援する。本ガイドはClaude Codeを単なるコーディングツールではなく、自然言語でプログラムできるエージェント実行環境として活用する手法とそのデザインパターンを提示する。

本ガイドで使用するマクロ構文は、CLAUDE.mdで定義された文法に基づいて動作する。ユーザーは自然言語でマクロを記述し、ClaudeがCLAUDE.mdの文法規則に従って実行する。**実際の実行前に、CLAUDE.mdファイルをClaude Codeに読み込ませる必要がある。**



## 🤖 Core Concept: Claude Codeをインタープリタとしたエージェントプログラミング

本ガイドは、**自然言語をマクロコードとし，　LLMをインタープリタとして構造化されたタスクを実行する**自然言語マクロプログラミングを提示する。本ガイドではClaude Codeを実行環境として使用する。

従来のプログラミングが特定の構文を持つプログラミング言語をコンピュータに解釈させるのに対し、自然言語マクロプログラミングでは：

- **自然言語とマークダウン記法**をプログラムとして記述
- **Claude Code**がそれを解釈・実行するインタープリタとして機能
- **Task tool、TODO tool、変数管理、条件分岐、並列実行**等の高度な制御構造を自然言語で実現
- **エージェントシステム**として複雑なタスクを自動化・最適化

直感的な自然言語でエージェントの振る舞いを設計し、Claude Codeに実行させることが可能になる。

このドキュメントで示す自然言語マクロプログラミングとデザインパターンの大きな特徴は以下の3点に集約される。
1. 可読性とアクセシビリティ: 自然言語で記述するため、非専門家でも理解・編集が可能。
2. 構造化と再利用性: デザインパターンを用いて、複雑なタスクを体系的に構築できる。
3. メタプログラミングへの高い適性: 「振る舞い」自体をデータとして扱い、操作できる。

自然言語マクロプログラミングは、メタプログラミングとしての側面も有する。自然言語マクロプログラミングでは、LISPに似た「コードとデータの等価性」を持つ。この特性は、特にメタプログラミング（プログラムを操作するプログラムを書くこと）を容易にする。マクロを動的に生成し、それを改めて自身に組み込み実行させる、といった高度なメタプログラミングが可能である。

## 🌍 フレームワークの汎用性と設計思想

この「自然言語マクロプログラミング」という概念と設計思想は、特定のLLMに縛られるものではない。一定の条件を満たす他の高性能なLLMにも十分に適用可能であると予想される。

このフレームワークの核心は、ツールや特定の製品ではなく、**LLMを自然言語インタープリタとして構造化されたタスクを実行する**というアプローチそのものにある。Claude Codeは、このアプローチを実現する優れた実行環境の一つとして位置づけられる。

**適用可能な条件**:
- 複雑な自然言語指示の理解と実行能力
- 変数管理と状態保持機能
- 外部ツール・モジュールとの連携能力
- マークダウン形式の構造化文書の解釈能力

## 🔗 既存プロンプト技術との相互補完関係

自然言語マクロプログラミングは、CoT（Chain of Thought）やReAct等の既存プロンプト技術と競合するものではなく、異なるレイヤーで動作する相互補完的な技術である。

### 技術レイヤーの違い

**既存プロンプト技術（CoT、ReAct等）**:
- **目的**: 個別の推論プロセスの最適化
- **範囲**: 単一タスク内での思考過程改善
- **例**: 問題分析の精度向上、段階的推論の実現

**自然言語マクロプログラミング**:
- **目的**: システム全体の構築・制御・統合
- **範囲**: 複数タスクの協調、状態管理、フロー制御
- **例**: パイプライン設計、並列処理、エラーハンドリング

### 組み合わせの実践例

```markdown
## CoT + Sequential Pipeline の組み合わせ
Step 1: CoTで複雑な問題を段階的に分析
Step 2: 分析結果を{{analysis_result}}に保存
Step 3: Sequential Pipelineで解決策を順次実行

## ReAct + Parallel Processing の組み合わせ
各並列タスクでReActによる情報収集を実行し、
結果をParallel Processingで統合処理
```

このように、既存技術の強みを活かしながら、システム全体の設計・制御に自然言語マクロプログラミングを活用することで、より高度で実用的なAIシステムの構築が可能になる。

## 🔍 高い説明可能性と責任あるAI開発への貢献

自然言語マクロプログラミングは、**高い説明可能性（Explainability）** を持つという、責任あるAI（Responsible AI）開発において極めて重要な特性を有している：

**説明可能性の特徴**:
- **自然言語による記述**: 処理ステップが人間に理解しやすい形で表現
- **透明な実行過程**: 各ステップの入力・出力・判断根拠が明確
- **監査可能性**: システムの動作を後から検証・追跡することが容易
- **デバッグ可能性**: 問題発生時の原因特定と修正が直感的

**責任あるAI開発への貢献**:
- 従来のブラックボックス的なAIシステムと比較して、意思決定過程の透明性が高い
- AIシステムの動作に対する説明責任を果たしやすい
- 人間による適切な監督と制御が可能
- エラーや偏見の発見・修正が容易

## ⚠️ 確率的動作特性について

本ガイドで紹介する自然言語マクロプログラミング手法は、LLM（大規模言語モデル）の確率的動作特性に基づく：

- **高確率動作**: 変数管理（`{{variable_name}}`）、外部モジュール実行（`filename.mdの実行`）等は十分に優れたLLMの場合には非常に高い確率で期待通りに動作する。変数管理は真のプログラミング変数ではなく、LLMによるコンテキスト内パターン認識に基づく確率的エミュレーションである
- **完全確定性の非保証**: 100%確定的な動作はLLMの性質上期待できない
- **実用的信頼性**: 実際の使用において十分な信頼性を持つレベルで動作する
- **段階的機能低下**: 理想的動作が困難な場合も、部分的な価値提供を継続する

### 特に失敗の可能性が高まるケース

このフレームワークを効果的に使用するには、LLMの確率的性質により予期しない動作を引き起こしやすい以下の状況を認識することが重要である：

**複雑な制御構造**:
ループのネスト（二重、三重ループ）や、多段のif-then-else分岐が深くなると、LLMが現在のコンテキストや状態を見失い、意図しない振る舞いをする可能性が高まる。

**長大なコンテキストにおける変数参照**:
マクロの冒頭で定義した変数を、非常に長い処理を経た末尾で参照する場合、LLMがその変数の正確な値や文脈を「忘れて」しまい、誤った参照をする可能性がある。

**自然言語固有の曖昧な指示**:
「スコアが十分に高くなったら」や「結果が良ければ」といった定性的・曖昧な条件分岐は、LLMの解釈に揺らぎを生じさせ、実行のたびに挙動が変わる原因となる。可能な限り、「{{score}} > 90」のように定量的な指示を用いることが推奨される。


## 🎯 目次

1. **自然言語マクロプログラミングの基本概念**
   - 情報管理と結果の受け渡し
   - 条件分岐とマルチタスク処理の実装

2. **10のデザインパターン**
   - Sequential Pipeline（順次パイプライン）
   - Parallel Processing（並列処理）  
   - Conditional Execution（条件分岐）
   - Loop & Modular Programming（繰り返し・モジュール）
   - Problem Solving & Recursion（問題解決・再帰）
   - Learning from Experience（経験学習・知識蓄積）
   - Environment sensing, Knowledge-base and Environment model（環境センシング・知識ベース・環境モデル）
   - Human-in-the-Loop（人間協調型エージェント設計）
   - Error Handling（エラーハンドリング）
   - Debug & Tracing（デバッグ・トレーシング）

3. **実践的なシステム構築能力**
   - 段階別サンプルによる実習
   - 俳句生成システム等の応用例
   - 業務自動化への応用手法

---

**Version**: 1.0  
**Authors**: Tadashi Wadayama & Claude Code (Anthropic Inc.)  
**Created**: 2025-06-18  
**License**: MIT License (2025)

---

## 🎯 本研究の目的と意義

### 研究の背景と課題

現代のAI技術の急速な発展に伴い、人間-機械協働システムの設計手法に対する新たなアプローチが求められている。従来のプログラミングパラダイムは専門的知識を前提とし、非専門家によるエージェントシステム構築には高い参入障壁が存在する。本研究は、Claude Codeの自然言語処理能力とマークダウン記法を活用した構造化タスク記述により、この課題の解決を目指す。

### 本研究が提案するアプローチ

本研究では「自然言語マクロプログラミング」という新たな手法を提案する。この手法は以下の要素から構成される：

1. **体系的設計パターンの確立**
   - 10のデザインパターンによる段階的習得体系の構築
   - 基本処理から高度な人間協調、デバッグまで包括的にカバーする設計手法
   - 再利用可能で拡張性を持つパターンライブラリの開発

2. **自然言語による構造化記述手法**
   - プログラミング構文に依存しない直感的なタスク記述方式
   - 人間の認知プロセスに親和性の高いマークダウン記法の活用
   - 曖昧性制御と構造化のバランスを考慮した記述規則

3. **段階的習得モデルの設計**
   - 基本パターン（順次・並列・条件分岐）から高度パターン（学習・環境理解・人間協調・エラーハンドリング・デバッグ）への体系的進歩
   - 理論学習と実践適用を統合した教育的アプローチ
   - 多様な分野での応用例による汎用性の実証

### Claude Code との協働における共有ドキュメント
Claude codeに自然言語マクロプログラミングのコードを書いてもらう場合について考える．コンテキストにこのドキュメントをいれておくことで，「売上データについて、Parallel Processingパターンで地域別・商品別・時系列の3軸分析を並列実行し、 結果を{{analysis_result}}に統合してレポート作成までSequential Pipelineで実行してください」と言った具体性を伴う指示を出すことができる．すなわち，プロンプト作成をClaude Codeにさせるときに，デザインパターンを指定して指示が出せる．人間とAIの協働における共通言語として，ここで示すデザインパターンを活用できる．


### 本手法の意義と将来展望

本研究が提案するアプローチは、AI技術の社会実装における重要な課題である人間-AI協働システム設計に対する方法論的基盤を提供することが期待される。

---

## 📋 Claude Code自然言語マクロプログラミングの代表的な構文
```markdown
- 条件分岐: 自然言語による条件指示（「...の場合は」「...に応じて」など）
- `{{variable_name}}`：変数参照
- 変数への保存：「...を{{variable_name}}に保存してください」
- 永続化保存：「{{variable_name}}をfilename.jsonに保存して永続化してください」
- ファイル読み込み：「filename.jsonを読み込んで{{variable_name}}に設定してください」
- 外部モジュール実行：「filename.mdの実行をしてください」
- ツール使用：自然言語で指示（例：「Webで調べて」「ファイルを読んで」，「TODOツールを使って」）
```

### 変数管理の特徴

自然言語による統一記法を採用している：

```markdown
# 結果保存
データを分析し、結果を{{analysis_result}}に保存してください。

# 結果参照  
{{analysis_result}}を基に報告書を作成してください。
```

### 制御構造

条件分岐は自然言語で柔軟に記述できる：

```markdown
## データ処理
{{file_size}}が1MB以上の場合は詳細分析を、
それ以外の場合は基本分析を実行してください。
```

### モジュール実行

外部モジュールファイルを呼び出すことで、モジュラー設計が可能である：

```markdown
## データ処理パイプライン
data_collection.mdの実行をしてください。
data_analysis.mdの実行をしてください。
report_generation.mdの実行をしてください。

## 条件付きモジュール実行
{{data_type}}に応じて以下を実行：
- テキストデータの場合：text_analysis.mdの実行をしてください
- 数値データの場合：numerical_analysis.mdの実行をしてください
```

**モジュール実行の利点**：
- **再利用性**: 共通処理を独立したモジュールとして管理
- **保守性**: 各モジュールを独立して開発・テスト可能
- **スケーラビリティ**: 大規模システムの構築が現実的
- **協働**: チーム開発での責任分担が容易

---

## 📚 基本構文サンプル集


### 1. 順次実行：Python学習ガイド作成

```markdown
## 基本情報収集
「Python入門」についてWebで調べ、初心者向けのポイント3つを{{basics}}に保存してください。

## 学習計画作成
{{basics}}を基に、1週間の学習スケジュールを{{schedule}}に保存してください。

## 最終ガイド作成
{{basics}}と{{schedule}}を組み合わせて「Python入門ガイド」を作成してください。
```

### 2. 並列実行：朝の準備分析

```markdown
## 朝の準備ルーティン分析
**以下の3つのタスクをTask toolを利用して並列実行してください：**

### 身支度分析
朝の身支度（洗顔、歯磨き、着替えなど）の特徴と効率化のコツを分析し{{grooming}}に保存してください。

### 朝食準備分析  
朝食の準備（メニュー選択、調理、栄養バランスなど）の特徴とアイデアを分析し{{breakfast}}に保存してください。

### 出発準備分析
外出準備（持ち物確認、交通手段、時間管理など）の特徴と工夫を分析し{{departure}}に保存してください。

## 総合朝ルーティン提案
{{grooming}}、{{breakfast}}、{{departure}}を組み合わせて、効率的で充実した朝の過ごし方を提案してください。
```

### 3. 条件分岐：ファイル処理システム

```markdown
## ファイル確認
README.mdファイルのサイズ（文字数）を確認し{{file_size}}に保存してください。

## 処理方式決定
{{file_size}}に応じて以下を実行：
- 100文字未満の場合：「簡潔なファイルです。全文を表示します」と出力し、全文を{{content}}に保存
- 100文字以上の場合：「詳細なファイルです。要約を作成します」と出力し、要約を{{content}}に保存

## 結果表示
{{content}}を使って適切な形式で結果を表示してください。
```

### 4. ファイル永続化：学習進捗管理

```markdown
## 今日の学習記録
今日学習した内容を「Claude Code基本操作」として{{today_study}}に保存し、
{{today_study}}をstudy_log.jsonに保存して永続化してください。

## 進捗確認
study_log.jsonを読み込んで{{study_history}}に設定し、
学習継続日数と内容をまとめて表示してください。
```

### 5. 統合例：市場調査システム

```markdown
## 調査準備
「AI市場動向」を調査テーマとして{{theme}}に保存してください。

## 並列情報収集
**以下の3つのタスクをTask toolを利用して並列実行してください：**

{{theme}}について以下を調査してください：

### 技術動向
最新のAI技術トレンドを{{tech_trends}}に保存してください。

### 市場規模
AI市場の規模と成長予測を{{market_size}}に保存してください。

### 企業動向
主要AI企業の戦略を{{company_strategies}}に保存してください。

## 条件付きレポート作成
{{tech_trends}}、{{market_size}}、{{company_strategies}}の完全性を確認し：
- 3つすべて収集できた場合：{{tech_trends}}、{{market_size}}、{{company_strategies}}を統合した包括的な市場分析レポートを作成
- 2つ以下の場合：利用可能な情報での基本レポートを作成し、不足部分を明記

## 結果保存
最終レポートをai_market_report.jsonに保存して永続化してください。
```

---

## 🔄 基本デザインパターン

### Pattern 1: Sequential Pipeline（順次パイプライン）

**概要**: データを段階的に処理する基本パターン。`収集→処理→出力`の線形フローで確実な結果を得る。

**処理フロー**: `入力 → 処理1 → 処理2 → 処理3 → 出力`

**適用判断**:
- ✅ 処理に明確な順序がある
- ✅ 前段階の結果が次段階の入力になる
- ✅ 各段階を独立してテスト・改善したい
- ❌ 各処理が完全に独立している（→Parallel Processingを検討）

**実用例：ブログ記事作成システム**
```markdown
## トピック調査
「リモートワークのメリット」についてWebで調べ、主要なポイント5つを{{research}}に保存してください。

## 構成作成
{{research}}を基に、読みやすいブログ記事の構成（見出し3-5個）を{{structure}}に保存してください。

## 記事執筆
{{structure}}に従って、1500文字程度のブログ記事を執筆し{{article}}に保存してください。

## 最終確認
{{article}}の文章を校正し、読みやすさと正確性を確認して最終版を作成してください。
```

**習得のポイント**: 各段階で前の結果を必ず活用する変数設計が重要である

### 🛡️ ロバストなSequential Pipeline（大規模タスク対応）

**課題の認識**: 各段階のタスクが大きく複雑な場合、以下の問題が発生する可能性がある：
- 途中での処理失敗時の復旧困難
- 長時間実行における進捗管理の欠如  
- セッション中断時の再開困難
- 部分的完了状況の不透明性

**解決アプローチ**: TODOリストツールとの統合により、堅牢性と追跡可能性を向上させる

**改良ポイント**:
- **段階的分解**: 各メイン段階をサブタスクに細分化してTODO管理
- **進捗可視化**: 完了状況のリアルタイム確認
- **状態永続化**: セッション跨ぎでの継続実行対応
- **失敗回復**: 部分的失敗からの効率的復旧

**実用例：大規模調査レポート作成システム**
```markdown
## Phase 1: 調査計画の策定
以下のサブタスクをTODOリストに追加してください：
1. 「調査テーマの詳細化と範囲設定」- 優先度: 高
2. 「主要情報源の特定とアクセス可能性確認」- 優先度: 高  
3. 「調査手法の決定と実行計画策定」- 優先度: 中
4. 「スケジュールとマイルストーンの設定」- 優先度: 中

各タスクを順次実行し、完了時にステータスを「completed」に更新してください。

## Phase 2: 文献調査の実行
前フェーズ完了後、以下をTODOリストに追加：
1. 「学術論文の検索と収集」- 優先度: 高
2. 「業界レポートの分析」- 優先度: 高
3. 「統計データの取得と整理」- 優先度: 中
...

## 進捗確認
各フェーズ完了時に全体の進捗状況を確認し、次フェーズへの移行判定を実行してください。
```

**適用判断**:
- ✅ 総実行時間が30分以上の大規模タスク
- ✅ 複数セッションに跨る可能性がある処理
- ✅ 部分的失敗からの復旧が重要な業務
- ✅ 進捗の可視化・追跡が必要なプロジェクト
- ❌ 5分以内で完了する軽量タスク（→基本版を使用）

**習得のポイント**: TODOリストとSequential Pipelineの統合により、大規模タスクの体系的管理手法を習得

---

### Pattern 2: Parallel Processing（並列処理）

**概要**: 独立したタスクを同時実行して効率化と多角的視点を実現する処理パターン。

**処理フロー**: `入力 → [タスクA, タスクB, タスクC] → 統合 → 出力`

**適用判断**:
- ✅ 各処理が互いに独立している
- ✅ 同一データに対する異なる視点の分析が必要
- ✅ 処理時間の短縮が重要
- ❌ 処理に厳密な順序がある（→Sequential Pipelineを検討）

**実用例：週末の過ごし方分析システム**
```markdown
## 分析対象設定
「充実した週末」を分析対象として{{weekend}}に保存してください。

## 並列活動分析
**以下の3つのタスクをTask toolを利用して並列実行してください：**

{{weekend}}について以下の活動を分析してください：

### インドア活動分析
家で楽しめる活動（読書、映画、料理など）の特徴を分析し{{indoor}}に保存してください。

### アウトドア活動分析
外で楽しめる活動（散歩、スポーツ、旅行など）の特徴を分析し{{outdoor}}に保存してください。

### 社交活動分析
人との交流を楽しむ活動（友人との食事、イベント参加など）の特徴を分析し{{social}}に保存してください。

## 週末プラン提案レポート
{{indoor}}、{{outdoor}}、{{social}}を組み合わせて、バランスの取れた週末の過ごし方を提案してください。
```

**習得のポイント**: 各並列タスクが独立していることを確認し、必ず統合段階を設けることが重要である

---

## 🎌 実践例解説：俳句生成エージェントシステム

### システム概要

俳句生成エージェントシステムは、**Sequential Pipeline**と**Parallel Processing**を組み合わせた実用的な例である。創作プロセスをマクロ化することで、一貫した品質の俳句を効率的に生成する。

### 📁 実装ファイル

- **[haiku_direct.md](./haiku_direct.md)** - 完全な実装コード
- **学習目的**: Sequential PipelineとParallel Processingの組み合わせ手法
- **実行方法**: ファイルを直接Claude Codeで実行

### 🏗️ システム構造分析

#### Phase 1: Sequential Pipeline（順次実行）
```
テーマ生成 → 俳句並列作成 → 俳句評価・選択 → 最終レポート
```

**設計判断**: 各段階が前段階の結果に依存するため、Sequential Pipelineを採用

#### Phase 2: Parallel Processing（並列実行）
```
俳句並列作成セクション内：
├── Task 1: 第1テーマ俳句 (並列)
├── Task 2: 第2テーマ俳句 (並列)  
├── Task 3: 第3テーマ俳句 (並列)
└── Task 4: 第4テーマ俳句 (並列)
```

**設計判断**: 各俳句の作成は独立しているため、Parallel Processingで効率化

### 🔄 データフロー設計

**変数管理の活用**：

1. **テーマ共有**: `{{themes}}` → 全ての並列タスクで共通利用
2. **個別結果**: `{{haiku_1}}`, `{{haiku_2}}`, `{{haiku_3}}`, `{{haiku_4}}` → 独立保存
3. **評価統合**: `{{best_selection}}` → 並列結果の統合評価
4. **最終出力**: 全変数を参照した包括的レポート

### 💡 学習ポイント

#### 1. パターンの適切な組み合わせ
- **外枠**: Sequential Pipeline（プロセス全体）
- **内部**: Parallel Processing（俳句生成部分）
- **全体**: 単一の統合されたシステム

#### 2. 変数設計の工夫
```markdown
# 共通入力変数
{{themes}} → 全並列タスクで使用

# 個別出力変数  
{{haiku_1}}, {{haiku_2}}, {{haiku_3}}, {{haiku_4}} → 各タスクの独立結果

# 統合変数
{{best_selection}} → 並列結果の評価・選択
```

#### 3. 実用的な品質管理
- **多様性確保**: 4つの異なるテーマで多角的アプローチ
- **客観評価**: 明確な評価基準による選択プロセス
- **包括記録**: 全工程の結果を最終レポートで保存

### 🎯 実装の特徴

#### 自然言語による直感的指示
```markdown
# 技術的でない、自然な表現
「5-7-5の音律構造に従い、テーマの奇妙さと独特さを表現してください」
「最も奇妙で印象的な俳句を選択してください」
```

#### 完全な自動化
- 人間の介入なしで完結
- 全プロセスが自動実行
- 一貫した品質の保証

### 📈 応用可能性

このシステム構造は以下の分野への応用が考えられる：

- **創作活動**: 小説、詩、キャッチコピー生成
- **コンテンツ制作**: 記事、プレゼン資料、企画書
- **意思決定支援**: 複数案の生成・評価・選択
- **品質保証**: 多角的検証による品質向上

### 🎓 学習効果

`haiku_direct.md`を理解することで以下が期待される：

1. **基本パターンの実践的組み合わせ**の習得
2. **変数管理の効果的な設計手法**の理解  
3. **実用的なシステム構築能力**の獲得
4. **自然言語マクロプログラミングの本質**の体得

このファイルは、基本パターンから実用システムへの**有用な架け橋**となる学習教材である。

---

### Pattern 3: Conditional Execution（条件分岐）

**概要**: 状況に応じて異なる処理パスを動的に選択。データ特性やユーザー状況による最適な処理を実現し、柔軟で実用的なシステムを構築。

**処理フロー**: `入力 → 条件判定 → [処理A | 処理B | 処理C] → 出力`

**適用判断**:
- ✅ データや状況によって処理を変える必要がある
- ✅ エラーハンドリングや例外処理が重要
- ✅ ユーザー権限や設定による機能制御が必要
- ❌ 常に同じ処理で十分（→[Sequential Pipeline](./examples/sequential/)を検討）
- ❌ 複雑な問題分割が必要（→[Problem Solving & Recursion](./examples/problem_recursion/)を検討）

**実用例：ファイル処理の自動振り分けシステム**
```markdown
## ファイル情報の取得
処理対象のファイルを指定し、以下の情報を取得：
- ファイル形式を{{file_type}}に保存
- ファイルサイズを{{file_size}}に保存
- ファイル内容の行数を{{line_count}}に保存

## ファイル形式による処理分岐
{{file_type}}に応じて処理を分岐：

CSV形式の場合：
→ データ分析処理を実行し、結果を{{analysis_result}}に保存

JSON形式の場合：
→ 構造解析処理を実行し、結果を{{structure_result}}に保存

テキスト形式の場合：
→ 自然言語処理を実行し、結果を{{nlp_result}}に保存

その他の形式の場合：
→ 基本情報のみ抽出し、{{basic_info}}に保存

## ファイルサイズによる処理方法選択
{{file_size}}に応じて処理方法を調整：

10MB以上の場合：
→ 「大容量ファイルのため分割処理を実行します」
→ チャンク分割処理を{{chunk_processing}}で実行

1MB未満の場合：
→ 「小容量ファイルのため一括処理を実行します」
→ 一括処理を{{batch_processing}}で実行

## 結果の統合と出力
処理結果を{{final_result}}に統合し、
処理方法と実行時間を{{processing_log}}に記録
```

**習得のポイント**: 全ての条件パターンを網羅し、明確な判定基準を設定することが重要である

---

### 🔤 曖昧性許容処理（Ambiguity Tolerance）

**概要**: 自然言語処理ならではの特性を活用し、不明確な要求でも推測ベースで価値を提供する設計原則。従来のプログラミングでは「エラー」として処理される曖昧性を、システムの柔軟性として活用するアプローチ。

**4段階曖昧性対応戦略**: `明確 → 部分推測 → 高度推測 → 解釈不能`

1. **推測ベース継続**: エラー終了ではなく推測による処理継続
2. **確信度明示**: 推測レベルと不確実性をユーザーに透明化
3. **段階的詳細化**: より明確な要求への改善ガイダンス提供
4. **価値提供継続**: 最悪条件でも基本的フレームワークを提供

### 実用例：曖昧要求の段階的処理

```markdown
## 曖昧要求の解釈
{{user_request}}の曖昧性レベルを判定し、以下を実行：

明確な要求の場合：
→ 確定的に処理を実行し{{definitive_result}}に保存

部分的曖昧性の場合：
→ 「文脈から推測して処理します」として実行し{{inferred_result}}に保存
→ 「部分的推測を含みます」を{{uncertainty_note}}に記録

高度な曖昧性の場合：
→ 「最も可能性の高い解釈として処理します」として実行し{{speculative_result}}に保存
→ 「高度な推測による解釈です」を{{speculation_note}}に記録

解釈不能の場合：
→ 一般的なフレームワークを提供し{{fallback_framework}}に保存
→ 「具体的な要求の再入力を推奨します」を{{clarification_request}}に記録
```

### 🆚 従来プログラミングとの差別化

#### 従来のシステム設計
```
曖昧入力 → エラー → 処理停止 → ユーザー離脱
```

#### 曖昧性許容システム
```
曖昧入力 → 推測処理 → 有用結果 + 不確実性明示 → 段階的改善
```

**自然言語マクロプログラミングの独自価値**：
- **バイナリ判定からスペクトラムへ**: 成功/失敗ではなく確信度の段階的評価
- **完璧性から実用性へ**: 完全理解より部分的でも有用な価値提供
- **エラーから機会へ**: 曖昧性を柔軟性として活用する設計思想

この曖昧性許容処理により、人間-AI間の自然な対話における曖昧性への対応が改善され、より実用的なシステムの構築が可能となる。不確実な情報に基づく状況下においてエージェントが「完全停止」ではなく「推測継続」による処理を行うためのアプローチとなる。

---

## 📁 実践サンプル集

基本3パターンの詳細な実践例を以下で学習できる：

### 🔄 Sequential Pipeline（順次パイプライン）
- **初級**: [ブログ記事作成システム](./examples/sequential/blog_creation.md) - テーマ設定から校正まで
- **中級**: [学術調査パイプライン](./examples/sequential/research_pipeline.md) - 仮説構築から論文執筆まで
- **上級**: [大規模調査レポート作成システム](./examples/sequential/robust_research_system.md) - TODO統合ロバスト版

### ⚡ Parallel Processing（並列処理）
- **初級**: [市場分析システム](./examples/parallel/market_analysis.md) - 技術・市場・競合の同時調査
- **中級**: [競合調査システム](./examples/parallel/competitive_research.md) - 5社の並列企業分析

### 🎌 Conditional Execution（条件分岐）
- **初級**: [適応型学習システム](./examples/conditional/adaptive_tutor.md) - レベル別カリキュラム提供
- **中級**: [曖昧要求解釈システム](./examples/conditional/content_processor.md) - 自然言語曖昧性フォールバック

---

### Pattern 4: Loop & Modular Programming（状態管理・反復処理・モジュール設計）

**概要**: 状態を保持しながら反復的に処理を実行し、複雑なロジックを外部モジュールに分離してシステムの保守性と再利用性を向上させる高度なパターン。単純な反復処理から、条件制御と安全機構を備えた実用的なループシステムまでを段階的に構築。

**処理フロー**: `初期化 → [状態更新 → 外部モジュール実行 → 条件判定] → 終了処理`

**適用判断**:
- ✅ 状態を更新しながら反復処理が必要
- ✅ 継続的な改善や学習プロセスを実装したい
- ✅ 複雑な処理ロジックをループ内で実行する場合
- ✅ ループ処理の可読性と保守性が重要
- ✅ 条件制御と安全機構を備えたループが必要
- ❌ 状態変更のない単純な繰り返し（→基本的な反復で十分）

**モジュラー設計の価値**:
- **可読性**: ループ制御と処理ロジックの分離
- **再利用性**: 処理モジュールの独立した利用
- **保守性**: 各部分の独立した開発・テスト
- **スケーラビリティ**: 大規模システムの構築

### 🔢 基本例：シンプルなカウントアップシステム

まず、Loop & Modular Programmingの最も基本的な概念を理解するために、シンプルな固定回数ループから始めます：

```markdown
## 初期設定
カウンターを0として{{counter}}に設定してください。
合計値を0として{{total}}に設定してください。

## 5回繰り返しループ
以下を5回繰り返してください：

{{counter}}に1を加算してください。
{{total}}に{{counter}}を加算してください。
「回数: {{counter}}, 現在の合計: {{total}}」と表示してください。

## 最終結果
「完了！最終回数: {{counter}}, 総合計: {{total}}」と表示してください。
```

**学習ポイント**:
- **状態変数**: `{{counter}}`と`{{total}}`が各ループで更新される
- **固定回数**: 5回という明確な終了条件
- **状態の蓄積**: 繰り返しにより値が段階的に変化

### 🏗️ 応用例：モジュラー品質改善システム

*メインループファイル (main_improvement.md)*:
```markdown
## 初期設定
品質スコアを40として{{score}}に設定してください。
改善回数を0として{{iteration}}に設定してください。
改善履歴を空の状態として{{improvement_log}}に設定してください。

## 品質改善ループ
{{score}}が85以上または{{iteration}}が8回に達するまで以下を繰り返してください：

「=== 改善サイクル {{iteration}} 開始 ===」と表示してください。

improvement_process.mdの実行をしてください。

{{iteration}}に1を加算してください。

「=== 改善サイクル {{iteration}} 完了 ===」と表示してください。

## 最終結果報告
「品質改善プロセス完了」と表示してください。

以下の情報を報告してください：
- 最終品質スコア: {{score}}
- 実行した改善回数: {{iteration}}
- 改善履歴: {{improvement_log}}

改善プロセス全体の評価を実行してください。
```

*処理モジュールファイル (improvement_process.md)*:
```markdown
## 現在状況の分析
現在の品質スコア{{score}}を確認し、「現在のスコア: {{score}}」と表示してください。

## 適応的改善処理
{{score}}の値に応じて以下の改善処理を実行してください：

{{score}}が60未満の場合：
→ 「基礎改善処理を実行します」と表示してください
→ {{score}}に12を加算してください
→ 「基礎改善: +12点」を{{improvement_log}}に追記してください

{{score}}が60以上75未満の場合：
→ 「中級改善処理を実行します」と表示してください  
→ {{score}}に8を加算してください
→ 「中級改善: +8点」を{{improvement_log}}に追記してください

{{score}}が75以上85未満の場合：
→ 「高級改善処理を実行します」と表示してください
→ {{score}}に5を加算してください
→ 「高級改善: +5点」を{{improvement_log}}に追記してください

{{score}}が85以上の場合：
→ 「微調整処理を実行します」と表示してください
→ {{score}}に2を加算してください
→ 「微調整: +2点」を{{improvement_log}}に追記してください

## 改善結果の記録
改善後の新しいスコア{{score}}を表示してください。

実行した改善の種類と効果を確認し、「改善処理完了」と表示してください。
```

### 🔄 終了条件の3つのパターン

#### 1. 純粋条件終了
```markdown
{{score}}が目標値に達するまで処理を継続：
→ 回数制限なし、条件のみで終了判定
→ 確実な目標達成、予測可能な収束
```

#### 2. 複数条件終了
```markdown
以下のいずれかが満たされるまで継続：
→ 品質目標達成 OR エラーゼロ達成 OR 改善停滞検出
→ 複雑な終了判定、柔軟な制御
```

#### 3. 安全機構付き終了
```markdown
主条件: {{score}} >= 目標値
安全制限: 最大{{max_iterations}}回まで
→ 無限ループ防止、実用的な制限設定
```

**習得のポイント**: 
1. **ループ制御と処理ロジックの分離**により複雑度を管理
2. **状態変数の一貫した管理**で予測可能な動作を実現  
3. **適切な終了条件設計**で実用性と安全性を両立
4. **外部モジュール実行**で再利用可能なコンポーネント設計

### 📁 実践サンプル

Loop & Modular Programming の詳細な実践例：

- **初級**: [学習進捗管理システム](./examples/loop_modular/learning_progress.md) - スコア向上の反復学習
- **中級**: [プレゼンテーション品質最適化システム](./examples/loop_modular/presentation_optimizer.md) - 複数軸での反復改善



---

### Pattern 5: Problem Solving & Recursion（動的問題解決・再帰的分割）

**概要**: 複雑な問題をTODOツールを活用して再帰的に分割し、段階的に解決する高度なパターン。大きな問題を理解可能な単位まで分解し、確実な進歩を積み重ねて最終的な統合解決を実現。

**処理フロー**: `問題分析 → 分解判定 → [再帰分割 | 具体実行] → 統合解決`

**適用判断**:
- ✅ 複雑で多段階の問題解決が必要
- ✅ 問題を段階的に分割できる構造
- ✅ 確実な進捗管理と状態保持が重要
- ✅ 中断・再開可能な長期タスク
- ❌ 単純で分割不要な処理（→[Sequential Pipeline](./examples/sequential/)を検討）


**再帰的思考の価値**:
- **分解**: 大きな問題を理解可能な単位に分割
- **判定**: 各タスクの分解可能性を適切に評価
- **実行**: 分解不可能なタスクの具体的完了
- **統合**: 分散した成果の体系的な結合

### 🎯 段階的習得の3ステップ

#### ステップ1: TODOツール基本操作
```markdown
## TODOリスト基本操作体験

簡単なタスク「買い物リスト作成」でTODOツールの基本操作を習得：

現在のTODOリストを確認してください。

以下のタスクをTODOリストに追加してください：
1. 「食材確認」- 優先度: 高
2. 「買い物リスト作成」- 優先度: 高  
3. 「買い物実行」- 優先度: 中

各タスクを順次実行し、完了時にステータスを「completed」に更新してください。

最終的にすべてのタスクが完了したことを確認してください。
```

#### ステップ2: 基本的な問題分割
```markdown
## 単純な問題分割システム

メインタスク「週末の掃除計画」を分割してTODOリストで管理：

メインタスクを以下のサブタスクに分割してTODOリストに追加：
1. 「リビング掃除」- 優先度: 高
2. 「キッチン掃除」- 優先度: 高
3. 「バスルーム掃除」- 優先度: 中
4. 「ゴミ出し」- 優先度: 低

各サブタスクについて：
- 具体的な作業内容を決定
- 作業完了後、ステータスをcompletedに更新
- 全完了後、掃除計画全体の成果をまとめて報告
```

#### ステップ3: 再帰的問題解決
```markdown
## 高度な再帰分割システム

メインタスク「料理レシピ作成」による再帰実装：

## フェーズ1: 初期問題分割
メインタスクを主要サブタスクに分解してTODOリストに追加

## フェーズ2: 再帰的分解判定
各pendingタスクについて：
- 分解可能性を判断
- 分解可能→詳細サブタスクを作成してTODO追加
- 分解不要→具体的作業を実行してcompleted

## フェーズ3: 継続的処理
pendingタスクが残る限り、フェーズ2を繰り返し実行

## フェーズ4: 最終統合
全タスク完了後、結果を統合して完全なレシピとして提示
```

### 🔄 TODOリストツールの3つの利点

#### 1. 複雑度の管理
```markdown
大きな問題 → 理解可能な単位 → 段階的解決：
→ 人間の認知限界を考慮した分割
→ 各ステップでの確実な理解と実行
```

#### 2. 確実な進歩保証
```markdown  
分解不可能 → 具体実行 → completed → 積み重ね：
→ 各タスク完了が全体の前進を保証
→ 中途半端な状態を残さない設計
```

#### 3. 中断・再開可能性
```markdown
TODOリスト → 状態保持 → セッション跨ぎ → 継続処理：
→ 長期プロジェクトの柔軟な管理
→ 複数人での作業分担も可能
```

**習得のポイント**: 
1. **再帰的分解思考**でプログラミング的問題解決を習得
2. **TODOツール連携**による確実な状態管理を実現
3. **分解判定ロジック**で適切な粒度制御を学習
4. **統合プロセス**で分散した成果の体系化を実践

### 📁 実践サンプル

Problem Solving & Recursion の詳細な実践例：

- **初級**: [タスク分解システム](./examples/problem_recursion/task_decomposition.md) - カレーレシピ作成による再帰分割の実践（実行時間: 3-5分）
- **中級**: [プロジェクト管理システム](./examples/problem_recursion/project_management.md) - 複雑な階層管理とイベント企画の完全分解（実行時間: 8-12分）

---

### Pattern 6: Learning from Experience（経験学習・知識蓄積・記憶管理）

**概要**: エージェントが実行した処理の結果を永続化ファイルに保存し、蓄積された経験から学習して意思決定の質を向上させる高度なパターン。単純な経験記録から、類似性判定による知見検索、失敗パターン認識まで段階的に構築。

**処理フロー**: `経験記録 → 知見蓄積 → 経験検索 → 知見活用`

**適用判断**:
- ✅ 過去の経験を活用して判断精度を向上させたい
- ✅ 継続的な学習・改善プロセスを実装したい  
- ✅ 類似状況での知見を効率的に利用したい
- ✅ 失敗パターンの予測・回避システムを構築したい
- ❌ 単発処理で記憶が不要（→基本パターンを検討）

**経験学習の価値**:
- **記憶**: 過去の成功・失敗事例の永続化
- **学習**: 経験からパターンを抽出し知見化
- **検索**: 類似状況での関連経験の効率的発見
- **活用**: 蓄積された知識に基づく改善された意思決定

### 🍳 基本例：料理経験の蓄積学習システム

まず、Learning from Experienceの最も基本的な概念として、経験の記録→蓄積→活用サイクルを実践します：

```markdown
## 初期料理実験
今日の夕食として「チャーハン」を作ってみる。

使用材料: 米2合、卵2個、ネギ、醤油、塩
調理時間: 20分
評価: 味が薄い、べたつき気味（5/10点）

## 経験の記録
以下の料理経験をlearning_memory.jsonファイルに保存して永続化してください：

{
  "cooking_experiences": [
    {
      "date": "今日",
      "dish": "チャーハン",
      "ingredients": ["米2合", "卵2個", "ネギ", "醤油", "塩"],
      "cooking_time": 20,
      "score": 5,
      "problems": ["味が薄い", "べたつき気味"],
      "lessons": "調味料の量要調整、火力強化必要"
    }
  ]
}

## 改善実践
learning_memory.jsonを読み込んで{{past_experience}}に設定してください。

{{past_experience}}の教訓を活用して改善版チャーハンを作ります：

改善材料: 米2合、卵2個、ネギ、醤油（多め）、塩、鶏ガラスープ、ごま油
調理時間: 18分
評価: 味が濃厚、パラパラ食感（8/10点）

この改善結果も{{past_experience}}に追加してlearning_memory.jsonに保存してください。

## 学習完了とクリーンアップ
「料理学習サイクル完了！」と表示してください。

次回実行時のために、learning_memory.jsonファイルを削除してください。
```

**学習ポイント**:
- **経験記録**: 具体的な結果をJSON形式で永続化
- **教訓抽出**: 問題点から具体的な改善点を導出
- **知見活用**: 過去経験を参照した改善実践

### 🔄 継続学習：Loop Pattern + Learning from Experience

数当てゲーム学習システムでは、過去の推定履歴を活用して段階的に効率的な探索戦略を習得します：

```markdown
## ゲーム初期設定
1から100までの数からランダムに秘密の数を選択し{{secret_number}}に設定してください。
（動作確認のため、秘密の数を表示してください）

game_history.jsonを読み込んで{{game_history}}に設定してください。
推定回数を0として{{attempt_count}}に設定してください。

## 学習推定ループ
{{attempt_count}}が10回に達するか正解するまで以下を繰り返してください：

{{attempt_count}}に1を加算してください。

「=== 推定回数 {{attempt_count}} ===」と表示してください。

## 過去履歴に基づく推定値決定
{{game_history}}を参照して次の推定値を決定してください。

初回の場合：
→ 1から100の間で推定値を選択してください

2回目以降の場合：
→ {{game_history}}の内容を確認し、あなたなりの方法で次の推定値を決定してください

推定値を{{current_guess}}に設定し、「推定値: {{current_guess}}」と表示してください。

## フィードバック判定
{{current_guess}}と{{secret_number}}の差を計算し、以下の段階的フィードバックを提供してください：

差が20以上の場合：
→ {{current_guess}} < {{secret_number}}: 「{{current_guess}}はだいぶ小さいです」
→ {{current_guess}} > {{secret_number}}: 「{{current_guess}}はだいぶ大きいです」

差が5-19の場合：
→ {{current_guess}} < {{secret_number}}: 「{{current_guess}}は少し小さいです」
→ {{current_guess}} > {{secret_number}}: 「{{current_guess}}は少し大きいです」

差が1-4の場合：
→ 「{{current_guess}}はとても近いです！」

差が0の場合：
→ 「正解！{{current_guess}}が秘密の数です！」と表示してループ終了

## 履歴更新
推定結果を{{game_history}}に追加し、game_history.jsonに保存してください：
- 推定回数
- 推定値
- フィードバック結果
- あなたが気づいたこと（任意）

## 最終学習成果
ゲーム完了後、{{game_history}}から学習プロセスを振り返ってください：
「数当て学習完了！{{attempt_count}}回で正解到達」
「あなたが発見した学習効果や戦略について自由に分析してください」

## 学習完了とクリーンアップ
次回実行時のために、game_history.jsonファイルを削除してください。
```


**習得のポイント**: 
1. **経験永続化**でセッション跨ぎの長期記憶を実現
2. **継続学習サイクル**で反復的な改善プロセスを構築
3. **知見抽出**で個別経験から一般的な法則性を発見
4. **状態管理**で学習の進歩を追跡・可視化

### 📁 実践サンプル

Learning from Experience の詳細な実践例：

- **初級**: [文章スタイル分析・改善システム](./examples/learning_experience/writing_style_learning.md) - JSON永続化による文章経験の記録・蓄積・活用（実行時間: 5-8分）
- **中級**: [プロンプト継続改良システム](./examples/learning_experience/prompt_improvement_learning.md) - Loop Pattern統合による段階的プロンプト最適化学習（実行時間: 8-12分）
- **上級**: [ブラインド最適化学習システム](./examples/learning_experience/blind_optimization_learning.md) - ブラインド探索環境での最適解発見学習（実行時間: 3-6分）

---

### Pattern 7: Environment sensing, Knowledge-base and Environment model（環境センシング・知識ベース・環境モデル）

**概要**: エージェントが環境を理解し、状況に応じた最適な判断を行うための知識体系とモデル構築手法。基本パターンの実行能力に「環境理解」と「状況判断」の知的能力を追加し、より実用的で適応的なエージェントシステムを実現。

**処理フロー**: `環境センシング → 知識照合 → 状況推定 → 経験統合 → 行動判断`

### 📚 エージェントの環境理解システム

**基本概念**: エージェントシステムは自身が動作する「環境」に関する知識を体系的に保持・活用する必要がある

**環境知識の3層構造**:
```
環境に関する知識 = LLMの持つ常識 + ナレッジベース + 環境モデル
```

**情報統合による判断プロセス**:
```
センシング情報 + ナレッジベース + 環境モデル + 経験学習 → 行動判断
```

### 🔍 環境センシング（Environment Sensing）

**定義**: エージェントが実世界・デジタル環境から情報を取得し、現在の状況を把握する基本機能

**適用判断**:
- ✅ 時刻・日付等の時間的情報が必要
- ✅ ファイル・データベースの現在状態を確認したい
- ✅ 外部システム・Web情報を取得したい
- ❌ 静的な情報のみで十分（→ナレッジベースで対応）

**センシング手法の体系**:

#### 時間的情報の取得
```markdown
## 現在時刻の取得
dateコマンドを実行して現在の日時を確認し、{{current_time}}に保存してください。

## 曜日別処理
{{current_time}}から曜日を判定し、以下を実行：
- 平日の場合：業務モードの処理を実行
- 週末の場合：メンテナンスモードの処理を実行
```

#### ファイル・データ状態の取得
```markdown
## ファイル状態確認
project_status.jsonを読み込んで{{project_state}}に設定してください。

## データ整合性チェック
{{project_state}}の内容を分析し：
- 必須項目の完全性確認
- データ更新日時の検証
- 異常値・欠損値の検出
```

#### 外部情報の取得
```markdown
## Web情報収集
「最新の技術動向」についてWebで調べ、重要なポイント3つを{{tech_trends}}に保存してください。

## 情報の信頼性評価
{{tech_trends}}について：
- 情報源の信頼性評価
- 情報の新しさ確認
- 複数ソースでの裏付け取得
```

**実用例：週間タスク管理エージェント**

エージェントプログラミングの核心概念「**環境センシング→判断→行動**」を実装する例：

```markdown
## 環境センシング：現在の曜日取得
dateコマンドを実行して現在の曜日を確認し、{{current_day}}に保存してください。

## 曜日別タスク実行
{{current_day}}に応じて以下を実行し、結果を{{daily_result}}に保存してください：

月曜日の場合：
→ 週始めプランニング（1週間の目標設定）を実行

火曜日〜木曜日の場合：
→ 集中作業モード（重要タスクの進捗確認）を実行

金曜日の場合：
→ 週末準備モード（週の振り返りと次週準備）を実行

土曜日・日曜日の場合：
→ リフレッシュモード（休息とリチャージ活動）を実行

## エージェント動作報告
{{current_day}}と{{daily_result}}を組み合わせて、今日のエージェント動作報告書を作成してください。
```

**センシングの要素**:
- **実世界情報**: dateコマンドによる時刻・曜日の取得
- **デジタル情報**: ファイル・データベースの状態確認
- **外部情報**: Web検索・API呼び出しによる最新情報取得
- **状態変化**: 前回実行時からの変化・差分の検出

### 📖 ナレッジベース（Knowledge Base）

**定義**: 環境に関する固有知識をテキストやJSON形式で構造化したもの

**適用判断**:
- ✅ 業務固有のルール・手順が存在する
- ✅ FAQ・マニュアル等の明文化された知識がある
- ✅ 専門分野の知識体系が必要
- ❌ 一般常識のみで対応可能（→LLMの基本知識で十分）

**実装形式**:

#### テキスト形式ナレッジベース
```markdown
## 顧客サポート知識ベース（customer_kb.md）
### 返品ポリシー
- 購入から30日以内
- 未開封・未使用品のみ
- レシート必須

### よくある質問
Q: 配送にかかる日数は？
A: 通常3-5営業日、お急ぎ便は翌日配送

### エスカレーション基準
- 返金要求 → マネージャー承認必要
- 技術的問題 → 技術サポートチーム転送
```

#### JSON形式ナレッジベース
```json
{
  "business_rules": {
    "discount_policy": {
      "vip_customer": 0.15,
      "regular_customer": 0.05,
      "minimum_order": 5000
    },
    "support_hours": {
      "weekday": "9:00-18:00",
      "weekend": "10:00-16:00"
    }
  },
  "contact_info": {
    "technical_support": "tech@company.com",
    "billing": "billing@company.com"
  }
}
```

**活用例：ナレッジベース参照システム**
```markdown
## 顧客問い合わせ対応
customer_kb.mdを読み込んで{{knowledge_base}}に設定してください。

## 問い合わせ内容分析
顧客からの問い合わせ「配送が遅れているようですが、どうなっていますか？」を{{inquiry}}に設定してください。

## 知識照合・回答生成
{{knowledge_base}}を参照して{{inquiry}}に最適な回答を生成し、{{response}}に保存してください。

## 対応履歴記録
{{inquiry}}と{{response}}をsupport_log.jsonに記録して永続化してください。
```

### 🌍 環境モデル（Environment Model）

**定義**: 環境を「状態を持つシステム」として捉え、その状態推定・予測を行うデジタルツイン

**適用判断**:
- ✅ 環境の状態変化を追跡する必要がある
- ✅ 複数要素の相互作用を理解したい
- ✅ 将来状態の予測が重要
- ❌ 静的な情報参照のみ（→ナレッジベースで十分）

**状態表現の設計**:

#### 基本的な状態管理
```json
{
  "system_state": {
    "timestamp": "2025-06-20T10:30:00Z",
    "inventory": {
      "product_a": 150,
      "product_b": 75,
      "product_c": 0
    },
    "active_orders": 12,
    "staff_status": {
      "available": 5,
      "busy": 3,
      "offline": 2
    }
  }
}
```

**活用例：在庫管理エージェント**
```markdown
## 現在状況の取得
inventory_status.jsonを読み込んで{{current_state}}に設定してください。

## 新規注文の処理
新規注文「商品A × 20個」を{{new_order}}に設定してください。

## 状態更新の実行
{{current_state}}と{{new_order}}を基に：
- 在庫数量の更新
- 在庫不足の警告判定
- 自動発注の必要性判断

更新された状態を{{updated_state}}に保存し、inventory_status.jsonに永続化してください。

## 予測・アラート機能
{{updated_state}}を分析し、今後24時間で在庫切れが予想される商品を{{alerts}}に抽出してください。
```

### 🔄 統合的判断システム

**4つの情報源を統合した高度な判断システム**:
`環境センシング + ナレッジベース + 環境モデル + 経験学習`

**実用例：会議アシスタントエージェント**
```markdown
## 環境情報の収集
dateコマンドで現在時刻を確認し{{current_time}}に設定してください。
meeting_schedule.jsonを読み込んで{{schedule}}に設定してください。
participant_profiles.jsonを読み込んで{{participants}}に設定してください。

## 状況判断の実行
{{current_time}}、{{schedule}}、{{participants}}を統合して：

会議開始15分前の場合：
→ 参加者への事前リマインダー送信
→ 資料準備状況の確認
→ 会議室設備の動作確認

会議中の場合：
→ 議事録の自動記録開始
→ 参加者の発言時間管理
→ アクションアイテムの抽出

会議終了後の場合：
→ 議事録の整理・配布
→ アクションアイテムのフォローアップ設定
→ 次回会議のスケジュール提案

結果を{{meeting_action}}に保存してください。

## 経験学習の統合
past_meetings.jsonから類似会議の成功パターンを{{lessons}}に読み込み、
{{meeting_action}}の改善に活用してください。

更新された知見をpast_meetings.jsonに追記して永続化してください。
```

### 🎯 Knowledge base と Environment model の連携

**相補的な活用**:
- **ナレッジベース**: 不変のルール・知識（「どうすべきか」）
- **環境モデル**: 動的な状態・予測（「現在どうなっているか」）
- **統合判断**: 両者を組み合わせた最適な行動決定

**Pattern統合の活用**:
- **Sequential Pipeline**: 知識照合→状況判断→行動実行の順次処理
- **Conditional Execution**: 状態に応じた条件分岐処理
- **Learning from Experience**: 判断結果からの知識・モデル更新
- **Parallel Processing**: 複数知識源の並列参照・統合

**習得のポイント**:
1. **適切な知識分離**でナレッジベースと環境モデルを使い分ける
2. **状態管理設計**で環境の重要な変化を確実に捕捉する
3. **多重情報統合**で各情報源の特性を活かした判断を実現
4. **継続的更新**で知識とモデルの精度を段階的に向上させる

### 📁 実践サンプル

Environment sensing, Knowledge-base and Environment model の詳細な実践例：

- **初級**: [時間感知ユーザー状態推定システム](./examples/environment_sensing/time_based_user_model.md) - 時刻センシングによる状態推定・応答適応
- **初級**: [プレゼンテーション構成アドバイザー](./examples/knowledge_base_patterns/presentation_advisor/presentation_advisor.md) - 専門知識による個別要件対応型構成生成

---

### Pattern 8: Human-in-the-Loop（HITL）- 人間協調型エージェント設計

**概要**: エージェントの自動処理に人間の判断・創造性・監督を戦略的に組み込み、効率性を保ちながら安全で責任あるシステムを構築する高度なパターン。適切な介入ポイント設計により、完全自動化の限界を克服し、人間とAIの相補的協調を実現。

**処理フロー**: `自動処理 → 介入判定 → [人間介入 | 継続実行] → 結果統合 → 記録保持`

**適用判断**:
- ✅ 創造的判断や戦略的方向性が重要
- ✅ 高リスクな決定や責任の明確化が必要
- ✅ 安全性確保やミスコンダクト防止が重要
- ✅ 品質基準や最終承認が必要
- ❌ 定型的で低リスクな処理（→完全自動化を検討）
- ❌ 高頻度で介入コストが効果を上回る場合

**HITLの4つの価値**:
- **創造性導入**: 人間の直感・発想をエージェント処理に組み込み
- **方向性調整**: 戦略的判断や優先順位の人間による修正
- **安全性確保**: 想定外のミスコンダクトや有害出力の防止
- **責任明確化**: 重要決定における人間の承認と責任の記録

### 🎯 効率的介入設計の原則

**介入ポイント最適化の考え方**:
```
介入効果 = (判断品質向上 + リスク軽減) - (時間コスト + 複雑性コスト)
```

**戦略的介入ポイント**:
1. **構想・計画段階**: 全体方向性や戦略の確認
2. **重要分岐点**: 複数選択肢からの意思決定
3. **品質確認段階**: 成果物の妥当性や安全性検証  
4. **最終承認段階**: 責任を伴う決定の確認

**効率性を保つバランス設計**:
- **階層的介入**: 重要度に応じた介入密度の調整
- **条件的介入**: 特定条件下のみの介入設計
- **並列処理**: 人間判断中の並行作業継続
- **事前設定**: 判断基準の事前合意による迅速化

### 🤝 Claude Code実装の4パターン

#### 1. 承認待機パターン
```markdown
## 重要決定の承認待機
以下の提案について承認をお願いします：
- 提案内容: {{proposal_content}}
- 想定効果: {{expected_effect}}
- リスク評価: {{risk_assessment}}

「承認」または「修正要求」を回答してください。
承認いただけるまで次のステップに進みません。

あなたの判断を{{human_decision}}に設定してください。
```

#### 2. 選択肢提示パターン
```markdown
## 戦略選択
{{current_situation}}の状況で、以下の選択肢があります：

A. {{option_a}} - メリット: {{merit_a}}, リスク: {{risk_a}}
B. {{option_b}} - メリット: {{merit_b}}, リスク: {{risk_b}}  
C. {{option_c}} - メリット: {{merit_c}}, リスク: {{risk_c}}

どの選択肢を選びますか？（A/B/C）
選択理由もお聞かせください。

あなたの選択を{{human_choice}}に設定してください。
```

#### 3. フィードバック統合パターン
```markdown
## 成果物の品質確認
{{generated_content}}を作成しました。

以下の観点でフィードバックをお願いします：
- 内容の正確性: 問題ありませんか？
- 安全性: 不適切な表現はありませんか？
- 改善提案: 追加・修正すべき点はありますか？

フィードバックを{{human_feedback}}に設定してください。
```

#### 4. 記録保持パターン
```markdown
## 人間介入記録の永続化
以下の介入記録をhitl_log.jsonに保存してください：

{
  "timestamp": "{{current_time}}",
  "intervention_type": "{{intervention_type}}",
  "human_decision": "{{human_decision}}",
  "context": "{{decision_context}}",
  "rationale": "{{human_rationale}}",
  "system_state": "{{system_state}}"
}
```

### 🛡️ 基本例：安全な記事作成システム

HITLの基本概念を実践する、承認待機を組み込んだ記事作成システム：

```markdown
## 記事テーマ設定
記事のテーマ「AI技術の最新動向」について、以下の構成を提案します：

1. AI技術の現状分析
2. 注目すべき技術トレンド  
3. 産業への影響予測
4. 今後の展望

この構成で進めてよろしいですか？
修正・追加したい点があれば指示してください。

あなたの承認を{{structure_approval}}に設定してください。

## 内容生成
{{structure_approval}}に基づいて各セクションの内容を生成し{{draft_content}}に設定してください。

## 安全性確認
{{draft_content}}について以下を確認してください：
- 事実関係の正確性
- 偏見や不適切な表現の有無
- 誤解を招く可能性のある記述

問題がある場合は修正指示をお願いします。
問題なければ「承認」と回答してください。

あなたの品質確認結果を{{quality_check}}に設定してください。

## 最終出力
{{quality_check}}が「承認」の場合のみ、最終記事をarticle_output.mdに保存してください。

## 介入記録
この一連の介入プロセスをhitl_log.jsonに記録してください：
- 構成承認: {{structure_approval}}
- 品質確認: {{quality_check}}
- 修正回数: {{revision_count}}
```

**学習ポイント**:
1. **段階的承認**で重要判断ポイントでの人間介入を実現
2. **明示的待機**で自動処理の制御と責任の明確化
3. **フィードバック統合**で人間の知見をシステムに反映
4. **記録保持**で意思決定プロセスの透明性確保

**習得のポイント**:
1. **適切な介入頻度**で効率性と安全性のバランスを実現
2. **明確な判断基準**で人間の負担を軽減し迅速な判断を促進
3. **柔軟な修正機能**で人間のフィードバックを効果的に活用
4. **責任の可視化**で意思決定の透明性と説明責任を確保

### 📁 実践サンプル

Human-in-the-Loop の詳細な実践例：

- **初級**: [創造的ブログ記事作成システム](./examples/human_in_the_loop/creative_blog_writer.md) - 戦略的介入ポイントでの人間協調型記事作成
- **中級**: [投資判断支援システム](./experiments/investment_decision_support/experiment.md) - 高リスク判断での責任明確化と段階的承認プロセス

---

## Pattern 9: Error Handling（エラーハンドリング）

### 概要

Error Handlingパターンは、システム実行中に発生する様々な種類の問題への対応手法を提供する。堅牢なエージェントシステムには欠かせない重要なパターンである。

**2つのアプローチ**:
1. **Try-Catch-Finally（従来形例外処理）**: 予期せぬ実行時エラーへの対応
2. **Graceful Degradation（段階的品質調整）**: 予見可能な制約や限界への適応

この2つのアプローチを組み合わせることで、様々な状況に対応できる堅牢なシステムを構築できる。

### 9-1: Try-Catch-Finally（従来形例外処理）

プログラミング言語のtry-catch-finallyと同様の構造を自然言語で実現する。API呼び出し失敗、ネットワークエラー、ツールのバグなど、予期せぬ実行時エラーに対する明示的な回復処理を定義する。

#### 基本構文パターン

```markdown
## メインタスクの実行
以下の処理を試してください（Try）:

primary_task.md を実行する。

もし失敗した場合は（Catch）:
backup_task.md を実行する。

最後に（Finally）:
実行結果（成功または失敗）を execution_log.txt に記録する。
```

#### 実践パターン

**1. API呼び出しの冗長化**
```markdown
## データ取得処理
以下の処理を試してください：

メインAPIからデータを取得し{{api_data}}に保存する。

失敗した場合：
バックアップAPIから同じデータを取得し{{api_data}}に保存する。

最終的に：
取得状況を{{api_status}}に記録し、api_log.jsonに保存する。
```

**2. ファイル操作の安全性確保**
```markdown
## ファイル書き込み処理
以下の処理を試してください：

{{report_data}}をfinal_report.mdに書き込む。

失敗した場合：
{{report_data}}をbackup_report.mdに書き込み、
「メインファイルの書き込みに失敗しました」というメッセージを表示する。

最終的に：
書き込み結果を処理ログに記録する。
```

**3. 外部ツール実行の信頼性向上**
```markdown
## 複数ツールでの検証
以下の処理を試してください：

Tool Aを使用してタスクを実行する。

失敗した場合：
Tool Bを使用して同じタスクを実行する。

それでも失敗した場合：
手動処理用の指示書を作成し、管理者に通知する。

最終的に：
実行結果と使用したツールを実行履歴に記録する。
```

### 9-2: Graceful Degradation（段階的品質調整）

理想的な動作が困難な場合に、品質を段階的に調整しながらも価値のある結果を提供し続ける手法である。完全な失敗ではなく、制限された環境下でも最大限の機能を維持する。

#### 基本概念

システムが理想的に動作できない場合でも、以下の優先順位で段階的に品質を調整：
1. **理想動作**: 完全な機能とクオリティ
2. **実用動作**: 主要機能を維持、一部制限
3. **最低限動作**: 核心価値のみ提供

#### 実践パターン

**1. リソース制約への対応**
```markdown
## レポート生成処理
十分な時間とリソースがある場合：
- 完全な市場分析
- 詳細なグラフ作成
- 包括的な推奨事項

時間が限られている場合：
- 主要指標のみの分析
- 簡易グラフ作成
- 重要な推奨事項のみ

緊急時：
- 最重要データのサマリーのみ
- テキストベースの簡潔な報告
```

**2. データ品質への適応**
```markdown
## 分析精度の調整
データが完全にそろっている場合：
高精度な統計分析を実行し{{detailed_analysis}}に保存する。

一部データが欠損している場合：
利用可能なデータで概算分析を実行し{{approximate_analysis}}に保存する。

データが大幅に不足している場合：
傾向分析のみを実行し{{trend_analysis}}に保存し、
「データ不足により詳細分析は実行できませんでした」と記録する。
```

**3. ツール利用可能性への対応**
```markdown
## 情報収集の段階的実行
Web検索ツールが利用可能な場合：
最新情報を含む包括的な調査を実行する。

Web検索が利用できない場合：
既存の知識ベースから関連情報を抽出する。

いずれも困難な場合：
一般的な知識に基づく基礎的な情報を提供し、
「最新情報の確認を推奨」との注意書きを追加する。
```

### Error Handling統合例

Try-Catch-FinallyとGraceful Degradationを組み合わせた堅牢なシステム例：

```markdown
## 市場分析レポート生成システム
以下の処理を試してください（Try）:

最新の市場データAPIから情報を取得し、詳細分析を実行する。

API取得に失敗した場合（Catch）:
既存データを使用した分析に切り替える（Graceful Degradation）。

既存データも不十分な場合:
業界一般動向に基づく概略分析を実行する（Further Degradation）。

最終的に（Finally）:
- 実行された分析レベルを記録
- データソースと信頼性レベルを明記
- 次回実行時の改善提案を記録
```

### 要点

**Try-Catch-Finally**:
1. **明示的エラー対応**: 失敗時の具体的な回復手順を事前定義
2. **冗長性の確保**: 複数の実行パスによる信頼性向上
3. **状況記録**: 成功・失敗の情報を後の改善に活用
4. **予期せぬ障害への備え**: システムの完全停止を回避

**Graceful Degradation**:
1. **段階的品質調整**: 完璧でなくても価値ある結果を提供
2. **制約条件への適応**: リソースやデータの制限下での最適化
3. **ユーザー期待の管理**: 制限事項の明確な説明
4. **継続的サービス**: 部分的な機能提供によるシステム価値の維持

---

## Pattern 10: Debug & Tracing（デバッグ・トレーシング）

**概要**: マクロ実行過程の状態追跡と問題診断機能。LLMが自然言語でデバッグ情報を実況し、変数値や判断根拠を明示することで、意図しない動作の原因特定と理解促進を実現する。デバッグ機能を使用する際は、事前に「debugger.mdを読み込んでください」でデバッガ機能を有効にします。

**処理フロー**: `実行 → 状態記録 → 分析・判断 → 診断情報出力`

**適用判断**:
- ✅ 複雑なマクロのデバッグが必要
- ✅ 学習目的でプロセス理解を深めたい
- ✅ 透明性と説明可能性が求められる
- ✅ 非技術者が処理過程を理解する必要がある
- ❌ 単純な処理でオーバーヘッドが不要（→[Sequential Pipeline](./examples/sequential/)を検討）
- ❌ 本番環境でのパフォーマンス重視時（→通常モード実行を推奨）

**実用例：学習スコア評価システムのデバッグ**

```markdown
## デバッグモードによる条件分岐の追跡

デバッグモードで以下を実行してください：
1. 学習スコアを85点として{{score}}に保存
2. {{score}}が80点以上の場合は『優秀』、60点以上80点未満は『良好』、それ未満は『要改善』として{{evaluation}}に保存
3. {{evaluation}}に基づいて具体的な次のステップを{{next_action}}に保存
4. 結果を整理して表示

# 期待されるデバッグ出力例：
[DEBUG] ステップ1: 学習スコアを{{score}}に保存
[DEBUG] 変数状態: {{score}} = 85
[DEBUG] ステップ2: 条件分岐による評価判定
[DEBUG] 条件1チェック: {{score}} >= 80 → 85 >= 80 = true
[DEBUG] 分岐決定: 条件1が真のため「優秀」ブランチを選択
[DEBUG] 変数状態: {{evaluation}} = "優秀"
[DEBUG] ステップ3: {{evaluation}}に基づく次のステップ決定
[DEBUG] 判断根拠: 優秀評価 → さらなる高度な学習機会を提供
[DEBUG] 変数状態: {{next_action}} = "高度な応用課題への挑戦を推奨"
```

**習得のポイント**: 従来のプログラミングでは不可能な「判断理由の自然言語説明」により、LLMの思考過程を可視化できる革新的なデバッグ手法である。

### 🔧 基本的なデバッグモード

**簡易デバッグ**: 変数値の確認のみ
```markdown
「簡易デバッグモードで{{weather}}を基に服装提案を作成してください」
→ 変数値と基本的な処理ステップのみ表示
```

**標準デバッグ**: 判断根拠を含む詳細情報
```markdown
「デバッグモードで{{budget}}と{{required_qty}}から商品推奨を実行してください」
→ 計算過程、条件判定、判断理由を詳細に説明
```

### 🛡️ 高度なトレーシング機能

**変数特化追跡**:
```markdown
「変数{{score}}をデバッグ追跡しながら評価システムを実行してください」
→ 特定変数の状態変化を重点的に監視
```

**エラー診断モード**:
```markdown
「エラー発生時に詳細説明付きで予算チェックシステムを実行してください」
→ 異常系での詳細な診断情報を提供
```

### 🎯 段階的習得の3ステップ

#### ステップ1: 基本変数のデバッグ
```markdown
## 変数操作の可視化

デバッグモードで以下を実行してください：
「今日の天気情報を{{weather}}に保存し、{{weather}}を基に服装提案を{{outfit}}に保存してください」

期待される効果：
- 変数への値設定プロセスの理解
- 変数間の依存関係の可視化
- 基本的なデバッグ出力の読み方
```

#### ステップ2: 条件分岐のデバッグ
```markdown  
## 判断プロセスの追跡

デバッグモードで以下を実行してください：
「{{temperature}}が20度未満で{{weather}}が雨の場合は『外出注意』、そうでない場合は『通常外出』として{{advice}}に保存してください」

期待される効果：
- 複合条件の評価過程の理解
- 論理演算（AND, OR）の可視化
- 分岐選択の理由説明
```

#### ステップ3: 複雑ワークフローのデバッグ
```markdown
## 多段階処理の全体追跡

デバッグモードで以下を実行してください：
「予算150000円、必要台数3台の条件で、商品データから価格フィルタリング→在庫チェック→推奨決定→見積作成の全工程を実行してください」

期待される効果：
- 長期プロセスでの状態管理
- 数値計算とビジネスロジックの連携
- エンドツーエンドの処理追跡
```


### 🔧 デバッグ構文リファレンス

#### 基本デバッグ指示
```markdown
「デバッグモードで[処理内容]を実行してください」
→ 標準レベルのデバッグ情報を出力
```

#### レベル別デバッグ
```markdown
# 簡易デバッグ（基本情報のみ）
「簡易デバッグモードで{{weather}}を基に服装提案を作成してください」

# 標準デバッグ（詳細情報）
「デバッグモードで{{budget}}から商品推奨システムを実行してください」

# 詳細デバッグ（最大詳細）
「詳細デバッグモードで複雑な在庫管理ワークフローを実行してください」
```

#### 特定要素デバッグ
```markdown
# 変数追跡
「変数{{score}}をデバッグ追跡しながら評価システムを実行してください」

# 条件分岐
「条件分岐をデバッグしながら推奨システムを実行してください」

# エラー診断
「エラー発生時に詳細説明付きで予算チェックシステムを実行してください」
```

#### デバッグ出力フォーマット
```
[DEBUG] ステップ[番号]: [実行内容の説明]
[DEBUG] 変数状態: {{variable_name}} = [現在値]
[DEBUG] 判断根拠: [条件評価の理由]
[DEBUG] 次のアクション: [次に実行する処理]
```

### 📋 デバッグ実行時の準備手順

デバッグ機能を使用する際は、以下の手順で準備してください：

#### 手順1: デバッグ機能の読み込み
```markdown
「debugger.mdを読み込んでください」  
→ デバッグ専用構文と出力機能を有効化
```

#### 手順2: デバッグ実行
```markdown
「デバッグモードで[処理内容]を実行してください」
→ 詳細な実行過程を可視化
```

#### 統合実行例
```markdown
「debugger.mdを読み込んでから、デバッグモードで商品推奨システムを実行してください」
```

**重要**: `debugger.md`ファイルには上記構文の完全版仕様が含まれており、実際のデバッグ時により詳細な参考資料として活用できます。このファイルには実験で検証された正確な構文定義、豊富な実行例、トラブルシューティングガイドが掲載されています。


---

## 免責事項

本ガイド『Claude Code 自然言語マクロプログラミングガイド』をご利用いただく前に、以下の内容をよくお読みいただき、ご理解の上でご自身の責任においてご活用ください。本ガイドの利用を開始した時点で、以下の内容に同意したものとみなします。

1.  **保証の否認**
    本ガイドで提供される情報、サンプルコード、および手法は、その正確性、完全性、有用性、特定目的への適合性を一切保証するものではありません。これらは「現状有姿（as-is）」で提供されます。

2.  **動作の不確実性**
    本ガイドで紹介する手法は、大規模言語モデル（LLM）の確率的な性質に強く依存しています。そのため、本ガイドに記載された通りに実行しても、常に期待通りの結果や動作が得られるとは限りません。実行のたびに結果が変動する可能性があります。

3.  **責任の制限**
    本ガイドの利用によって生じたいかなる損害（データの損失、業務の中断、利益の逸失、その他あらゆる直接的・間接的損害を含む）についても、著者および関係者は一切の責任を負いません。

4.  **自己責任の原則**
    本ガイドの手法の利用は、すべて利用者ご自身の責任において行ってください。特に、ファイル操作やコマンド実行（Bashなど）といった、ご自身のシステム環境に影響を与える可能性のある機能の利用には、細心の注意が必要です。**重要なデータが含まれる環境や本番環境での実行は絶対に避け、必ず安全なテスト環境で十分に検証してください。**

5.  **セキュリティについて**
    本ガイドで提示される手法を安全に利用するためのセキュリティ対策（信頼できないコードを実行しない、権限を適切に管理するなど）は、利用者ご自身の責任で行う必要があります。

6.  **外部サービスについて**
    本ガイドはAnthropic社のClaudeの機能に言及していますが、著者および本ガイドは同社とは独立しており、公式なものではありません。Claudeの利用規約や仕様は変更される可能性があり、それに伴い本ガイドの内容が古くなったり、利用できなくなったりする場合があります。

7.  **内容の変更**
    本ガイドの内容は、予告なく変更または削除されることがあります。

---

# 付録

## A.1: Claude Codeスラッシュコマンドによるシステム制御

エージェントがタスクを遂行する際に、与えられたリソース（予算、APIコール回数、許容時間、計算コストなど）の制約を意識する必要がある． 現実世界のエージェントは、無限のリソースを持つわけではなく，コスト意識やリソースの制約下での意思決定は、実用的なシステムにおいて不可欠である．

### スラッシュコマンドとは

**スラッシュコマンド**は、Claude Code内で「/」から始まる特殊なコマンドである。自然言語での対話中に直接実行でき、Claude Codeのシステム状態の確認・制御が可能になる。従来のコマンドライン操作とは異なり、対話の流れの中でシームレスに実行できる点が特徴である。

#### 主要ビルトインコマンド

Claude Codeには以下のビルトインスラッシュコマンドが用意されている：

- `/help` - 利用可能なコマンドの一覧と説明を表示
- `/clear` - 会話履歴とコンテキストをリセット（メモリ最適化）
- `/model` - 使用するClaudeモデルの切り替え（Opus/Sonnet等）
- `/ide` - IDE統合状態の確認（開いているファイル、linterエラー等）
- `/permissions` - ツール許可リストの管理


### ポイント

**1. 実際のシステム情報取得**
- `/ide`によるリアルタイム開発環境状態の確認
- `/help`による利用可能機能の動的把握
- 実際のシステム状態に基づく意思決定

**2. 動的環境制御**
- `/clear`による適切なタイミングでのメモリ管理
- `/model`による処理特性に応じた最適化
- パフォーマンス要件に応じた動的調整

**3. 条件分岐との組み合わせ**
- システム状態に基づく処理分岐
- 実行結果による次の行動の決定
- 実用的なワークフロー自動化

スラッシュコマンドの利用により、Claude Codeのシステム機能を活用した実践的なエージェント設計が可能になる。

## A.2: Event-Driven実行とシステム統合

現実世界の多くの処理は非同期的に発生する。ファイルの作成、メールの受信、センサー値の変化など、外部からの刺激に即座に反応する応答性の高いシステムが求められる。Event-Driven実行は、特定のイベントを非同期に待ち受け、検知時に対応するタスクを実行するプリミティブである。

### Event-Drivenとは

**Event-Driven実行**は、Sequential Pipeline（順次パイプライン）が同期的であるのに対し、外部イベントの発生を契機として非同期的にタスクを開始する実行モデルである。エージェントは待機状態でイベントを監視し、特定の条件が満たされた時点で自動的に処理を開始する。

### 外部トリガーモデル

最も現実的で堅牢なアプローチは、イベントの監視を既存の実績ある技術に委ね、LLMはトリガー後の処理に集中するハイブリッド設計である。

#### 主要な実装技術例

**1. cronによる時間トリガー**
- 指定した時間に自動的に呼び出し
- 定期実行タスクの基本的な実装方法

**2. watchdogによるファイル監視**
- Pythonのwatchdogライブラリを使用したファイルシステム監視
- ファイル作成、変更、削除イベントの検知
- 指定ディレクトリの常駐監視と即座の反応

**3. inotifyシステム**
- Linuxネイティブのファイルシステム監視機能
- 低レベルでの効率的なイベント検知

### 統合パターン

典型的な統合例：「ディレクトリ `/orders` を常時監視し、新しいファイル（例：`order123.json`）が作成されたら、そのファイルパスを引数として `order_processing.md` を評価」という常駐スクリプトを動作させる。

### ポイント

**1. 非同期処理の実現**
- 外部イベントへの即座の反応
- 複数イベントの並行監視
- システム全体の応答性向上

**2. 技術選択の柔軟性**
- 要件に応じた監視技術の選択
- 既存システムとの統合容易性
- 運用環境への適応性

**3. マクロファイルとの連携**
- イベント情報と処理ロジックの分離
- 動的な処理内容の変更
- 再利用可能な処理パターンの構築

Event-Driven実行により、リアルタイムシステムや業務自動化における高い応答性を持つエージェントシステムの構築が可能になる。

## A.3: ミッションクリティカル環境でのリスク軽減戦略

### 背景と課題認識

自然言語マクロプログラミングは、その直感性と高い説明可能性により、多様な分野での活用が期待される。しかし、LLM（大規模言語モデル）の確率的動作特性に由来する不確定性は、特定の環境では重大なリスクとなり得る。

**確率的不確定性がもたらす課題**：
- 100%の動作保証が原理的に困難
- 予期しない解釈や実行結果の可能性
- ミッションクリティカルな判断での信頼性要求との乖離
- 法的責任や安全性要求が厳格な分野での適用制約

**本節の目的**：
従来の確定的システムに求められる信頼性レベルに近づけるため、3層の防御戦略（設計段階の予防、実行時のエラーハンドリング、監査と継続改善）を通じて、自然言語マクロプログラミングの安全で責任ある活用を実現する。

### レイヤー1: 設計段階での予防的対策 (Proactive Design)

ワークフローの設計段階で、あらかじめリスクを低減する仕組みを組み込む。

#### 1. Human-in-the-Loop (HITL)の戦略的配置

**最重要ポイントでの承認ゲート設計**：

```markdown
## 重要意思決定での承認待ち
以下の処理内容を確認してください：
{{proposed_action}}

この処理には不可逆的な変更が含まれます。
Please respond with "Approved" or "Revision Required".
承認なしには次のステップには進行しません。

承認結果を{{human_approval}}に保存してください。

## 条件分岐による安全制御
{{human_approval}}が"Approved"の場合のみ：
Execute critical_operation.md

それ以外の場合：
処理を停止し、修正待ち状態に移行します。
```

**実装のポイント**：
- 不可逆的操作（ファイル削除、外部API呼び出し、金銭的取引等）の直前に必ず配置
- 「Human-in-the-Loop」パターンの「承認待ちパターン」を活用
- 明確な承認基準と却下基準を事前定義

#### 2. Graceful Degradation設計

理想的な条件が揃わない場合に、システムが即座に停止するのではなく、限定的ながらも価値を提供し続ける設計。

```markdown
## API接続の段階的代替処理
Try the following process:
外部APIから最新データを取得し、{{latest_data}}に保存

If it fails (Catch):
ローカルキャッシュから最新利用可能データを取得し、{{cached_data}}に保存
「注意：データは{{cache_date}}時点のものです」という警告を{{warning}}に設定

Finally:
{{latest_data}}または{{cached_data}}を使用して分析を継続
品質低下の警告がある場合は{{warning}}を結果に併記
```

#### 3. 実行権限の最小化

システムに与える権限を最小限に留め、危険を伴う機能への厳格なアクセス制御。

```markdown
## 権限制御の実装例
/permissions ファイル読み取り、テキスト生成のみ許可

危険なコマンド実行が必要な場合：
「この操作にはシステム管理者権限が必要です。
管理者による手動実行を要求します。」
処理を一時停止し、人間介入を待機
```

### レイヤー2: 実行時のエラーハンドリング (Runtime Error Handling)

予期せぬエラーが発生した際に、システムが壊滅的な状態に陥るのを防ぐ。

#### 1. Try-Catch-Finallyによる冗長化

```markdown
## 堅牢な外部連携処理
Try the following process:
メインAPIから重要データを取得

If it fails (Catch):
バックアップAPIから同様データを取得
取得元が異なることを{{data_source_warning}}に記録

If backup also fails (Catch):
既存データベースから利用可能な代替データを検索
「データの新鮮度に制限があります」を{{limitation_note}}に設定

Finally:
取得できたデータとその制限事項を明確に記録
処理結果と併せて品質レベルを報告
```

#### 2. 状態永続化と復旧メカニズム

特に長時間実行されるタスクでは、途中でプロセスが中断するリスクに対処。

```markdown
## 中断可能な長期処理の設計
長期タスクの各段階で進捗をprogress_state.jsonに保存：

Step 1 完了時：
{"completed_steps": ["data_collection"], "current_step": "analysis", "timestamp": "2025-01-15T10:30:00Z"}

Step 2 完了時：
{"completed_steps": ["data_collection", "analysis"], "current_step": "report_generation", "timestamp": "2025-01-15T11:45:00Z"}

## 復旧処理
progress_state.jsonを確認し、最後に完了したステップから処理を再開
「処理が{{timestamp}}から再開されました」をログに記録
```

### レイヤー3: 監査と継続的改善 (Auditing and Continuous Improvement)

システムの振る舞いを記録・分析し、将来のリスクを低減させる。

#### 1. ログ記録例

```markdown
## 全処理の監査ログ作成
実行開始時：
{"timestamp": "2025-01-15T09:00:00Z", "action": "process_start", "user_input": "{{original_request}}", "system_state": "{{initial_state}}"}

Human-in-the-Loop介入時：
{"timestamp": "2025-01-15T09:15:00Z", "action": "human_intervention", "decision": "{{human_decision}}", "rationale": "{{human_rationale}}", "context": "{{decision_context}}"}

エラー発生時：
{"timestamp": "2025-01-15T09:30:00Z", "action": "error_occurred", "error_type": "{{error_type}}", "error_message": "{{error_details}}", "recovery_action": "{{recovery_method}}"}

全ログをaudit_log.jsonに永続保存
```

#### 2. Learning from Experience活用

```markdown
## 失敗パターンの学習データ化
エラー発生時に学習データベースを更新：

failure_patterns.jsonに記録：
{
  "error_type": "API_timeout",
  "context": "high_traffic_period",
  "failed_action": "external_data_fetch",
  "successful_recovery": "switch_to_cached_data",
  "lesson_learned": "高トラフィック時間帯では最初からキャッシュデータを優先使用"
}

次回同様の状況で：
過去の失敗パターンをチェックし、予防的にキャッシュデータを使用
「過去の学習に基づき、安全な代替手段を選択しました」
```

自然言語マクロプログラミングの確率的特性を理解し、適切なリスク軽減策を講じることで、多様な分野での安全で責任ある活用が可能となる。
